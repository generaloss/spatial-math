package generaloss.spatialmath;

import generaloss.spatialmath.vector.Vec2f;
import generaloss.spatialmath.vector.Vec3f;

// MIT License
// Copyright(c) 2023 Jordan Peck (jordan.me2@gmail.com)
// Copyright(c) 2023 Contributors
// Modified; Original: https://github.com/Auburn/FastNoise

public class FastNoise {

    private static final float TWO_THIRDS = 0.666666666666666F; // (2 / 3)

    private static final float[] GRADIENTS_2D = { 0.130526192220052F, 0.99144486137381F, 0.38268343236509F, 0.923879532511287F, 0.608761429008721F, 0.793353340291235F, 0.793353340291235F, 0.608761429008721F, 0.923879532511287F, 0.38268343236509F, 0.99144486137381F, 0.130526192220051F, 0.99144486137381F, -0.130526192220051F, 0.923879532511287F, -0.38268343236509F, 0.793353340291235F, -0.60876142900872F, 0.608761429008721F, -0.793353340291235F, 0.38268343236509F, -0.923879532511287F, 0.130526192220052F, -0.99144486137381F, -0.130526192220052F, -0.99144486137381F, -0.38268343236509F, -0.923879532511287F, -0.608761429008721F, -0.793353340291235F, -0.793353340291235F, -0.608761429008721F, -0.923879532511287F, -0.38268343236509F, -0.99144486137381F, -0.130526192220052F, -0.99144486137381F, 0.130526192220051F, -0.923879532511287F, 0.38268343236509F, -0.793353340291235F, 0.608761429008721F, -0.608761429008721F, 0.793353340291235F, -0.38268343236509F, 0.923879532511287F, -0.130526192220052F, 0.99144486137381F, 0.130526192220052F, 0.99144486137381F, 0.38268343236509F, 0.923879532511287F, 0.608761429008721F, 0.793353340291235F, 0.793353340291235F, 0.608761429008721F, 0.923879532511287F, 0.38268343236509F, 0.99144486137381F, 0.130526192220051F, 0.99144486137381F, -0.130526192220051F, 0.923879532511287F, -0.38268343236509F, 0.793353340291235F, -0.60876142900872F, 0.608761429008721F, -0.793353340291235F, 0.38268343236509F, -0.923879532511287F, 0.130526192220052F, -0.99144486137381F, -0.130526192220052F, -0.99144486137381F, -0.38268343236509F, -0.923879532511287F, -0.608761429008721F, -0.793353340291235F, -0.793353340291235F, -0.608761429008721F, -0.923879532511287F, -0.38268343236509F, -0.99144486137381F, -0.130526192220052F, -0.99144486137381F, 0.130526192220051F, -0.923879532511287F, 0.38268343236509F, -0.793353340291235F, 0.608761429008721F, -0.608761429008721F, 0.793353340291235F, -0.38268343236509F, 0.923879532511287F, -0.130526192220052F, 0.99144486137381F, 0.130526192220052F, 0.99144486137381F, 0.38268343236509F, 0.923879532511287F, 0.608761429008721F, 0.793353340291235F, 0.793353340291235F, 0.608761429008721F, 0.923879532511287F, 0.38268343236509F, 0.99144486137381F, 0.130526192220051F, 0.99144486137381F, -0.130526192220051F, 0.923879532511287F, -0.38268343236509F, 0.793353340291235F, -0.60876142900872F, 0.608761429008721F, -0.793353340291235F, 0.38268343236509F, -0.923879532511287F, 0.130526192220052F, -0.99144486137381F, -0.130526192220052F, -0.99144486137381F, -0.38268343236509F, -0.923879532511287F, -0.608761429008721F, -0.793353340291235F, -0.793353340291235F, -0.608761429008721F, -0.923879532511287F, -0.38268343236509F, -0.99144486137381F, -0.130526192220052F, -0.99144486137381F, 0.130526192220051F, -0.923879532511287F, 0.38268343236509F, -0.793353340291235F, 0.608761429008721F, -0.608761429008721F, 0.793353340291235F, -0.38268343236509F, 0.923879532511287F, -0.130526192220052F, 0.99144486137381F, 0.130526192220052F, 0.99144486137381F, 0.38268343236509F, 0.923879532511287F, 0.608761429008721F, 0.793353340291235F, 0.793353340291235F, 0.608761429008721F, 0.923879532511287F, 0.38268343236509F, 0.99144486137381F, 0.130526192220051F, 0.99144486137381F, -0.130526192220051F, 0.923879532511287F, -0.38268343236509F, 0.793353340291235F, -0.60876142900872F, 0.608761429008721F, -0.793353340291235F, 0.38268343236509F, -0.923879532511287F, 0.130526192220052F, -0.99144486137381F, -0.130526192220052F, -0.99144486137381F, -0.38268343236509F, -0.923879532511287F, -0.608761429008721F, -0.793353340291235F, -0.793353340291235F, -0.608761429008721F, -0.923879532511287F, -0.38268343236509F, -0.99144486137381F, -0.130526192220052F, -0.99144486137381F, 0.130526192220051F, -0.923879532511287F, 0.38268343236509F, -0.793353340291235F, 0.608761429008721F, -0.608761429008721F, 0.793353340291235F, -0.38268343236509F, 0.923879532511287F, -0.130526192220052F, 0.99144486137381F, 0.130526192220052F, 0.99144486137381F, 0.38268343236509F, 0.923879532511287F, 0.608761429008721F, 0.793353340291235F, 0.793353340291235F, 0.608761429008721F, 0.923879532511287F, 0.38268343236509F, 0.99144486137381F, 0.130526192220051F, 0.99144486137381F, -0.130526192220051F, 0.923879532511287F, -0.38268343236509F, 0.793353340291235F, -0.60876142900872F, 0.608761429008721F, -0.793353340291235F, 0.38268343236509F, -0.923879532511287F, 0.130526192220052F, -0.99144486137381F, -0.130526192220052F, -0.99144486137381F, -0.38268343236509F, -0.923879532511287F, -0.608761429008721F, -0.793353340291235F, -0.793353340291235F, -0.608761429008721F, -0.923879532511287F, -0.38268343236509F, -0.99144486137381F, -0.130526192220052F, -0.99144486137381F, 0.130526192220051F, -0.923879532511287F, 0.38268343236509F, -0.793353340291235F, 0.608761429008721F, -0.608761429008721F, 0.793353340291235F, -0.38268343236509F, 0.923879532511287F, -0.130526192220052F, 0.99144486137381F, 0.38268343236509F, 0.923879532511287F, 0.923879532511287F, 0.38268343236509F, 0.923879532511287F, -0.38268343236509F, 0.38268343236509F, -0.923879532511287F, -0.38268343236509F, -0.923879532511287F, -0.923879532511287F, -0.38268343236509F, -0.923879532511287F, 0.38268343236509F, -0.38268343236509F, 0.923879532511287F, };
    private static final float[] RAND_VECS_2D = { -0.2700222198F, -0.9628540911F, 0.3863092627F, -0.9223693152F, 0.04444859006F, -0.999011673F, -0.5992523158F, -0.8005602176F, -0.7819280288F, 0.6233687174F, 0.9464672271F, 0.3227999196F, -0.6514146797F, -0.7587218957F, 0.9378472289F, 0.347048376F, -0.8497875957F, -0.5271252623F, -0.879042592F, 0.4767432447F, -0.892300288F, -0.4514423508F, -0.379844434F, -0.9250503802F, -0.9951650832F, 0.0982163789F, 0.7724397808F, -0.6350880136F, 0.7573283322F, -0.6530343002F, -0.9928004525F, -0.119780055F, -0.0532665713F, 0.9985803285F, 0.9754253726F, -0.2203300762F, -0.7665018163F, 0.6422421394F, 0.991636706F, 0.1290606184F, -0.994696838F, 0.1028503788F, -0.5379205513F, -0.84299554F, 0.5022815471F, -0.8647041387F, 0.4559821461F, -0.8899889226F, -0.8659131224F, -0.5001944266F, 0.0879458407F, -0.9961252577F, -0.5051684983F, 0.8630207346F, 0.7753185226F, -0.6315704146F, -0.6921944612F, 0.7217110418F, -0.5191659449F, -0.8546734591F, 0.8978622882F, -0.4402764035F, -0.1706774107F, 0.9853269617F, -0.9353430106F, -0.3537420705F, -0.9992404798F, 0.03896746794F, -0.2882064021F, -0.9575683108F, -0.9663811329F, 0.2571137995F, -0.8759714238F, -0.4823630009F, -0.8303123018F, -0.5572983775F, 0.05110133755F, -0.9986934731F, -0.8558373281F, -0.5172450752F, 0.09887025282F, 0.9951003332F, 0.9189016087F, 0.3944867976F, -0.2439375892F, -0.9697909324F, -0.8121409387F, -0.5834613061F, -0.9910431363F, 0.1335421355F, 0.8492423985F, -0.5280031709F, -0.9717838994F, -0.2358729591F, 0.9949457207F, 0.1004142068F, 0.6241065508F, -0.7813392434F, 0.662910307F, 0.7486988212F, -0.7197418176F, 0.6942418282F, -0.8143370775F, -0.5803922158F, 0.104521054F, -0.9945226741F, -0.1065926113F, -0.9943027784F, 0.445799684F, -0.8951327509F, 0.105547406F, 0.9944142724F, -0.992790267F, 0.1198644477F, -0.8334366408F, 0.552615025F, 0.9115561563F, -0.4111755999F, 0.8285544909F, -0.5599084351F, 0.7217097654F, -0.6921957921F, 0.4940492677F, -0.8694339084F, -0.3652321272F, -0.9309164803F, -0.9696606758F, 0.2444548501F, 0.08925509731F, -0.996008799F, 0.5354071276F, -0.8445941083F, -0.1053576186F, 0.9944343981F, -0.9890284586F, 0.1477251101F, 0.004856104961F, 0.9999882091F, 0.9885598478F, 0.1508291331F, 0.9286129562F, -0.3710498316F, -0.5832393863F, -0.8123003252F, 0.3015207509F, 0.9534596146F, -0.9575110528F, 0.2883965738F, 0.9715802154F, -0.2367105511F, 0.229981792F, 0.9731949318F, 0.955763816F, -0.2941352207F, 0.740956116F, 0.6715534485F, -0.9971513787F, -0.07542630764F, 0.6905710663F, -0.7232645452F, -0.290713703F, -0.9568100872F, 0.5912777791F, -0.8064679708F, -0.9454592212F, -0.325740481F, 0.6664455681F, 0.74555369F, 0.6236134912F, 0.7817328275F, 0.9126993851F, -0.4086316587F, -0.8191762011F, 0.5735419353F, -0.8812745759F, -0.4726046147F, 0.9953313627F, 0.09651672651F, 0.9855650846F, -0.1692969699F, -0.8495980887F, 0.5274306472F, 0.6174853946F, -0.7865823463F, 0.8508156371F, 0.52546432F, 0.9985032451F, -0.05469249926F, 0.1971371563F, -0.9803759185F, 0.6607855748F, -0.7505747292F, -0.03097494063F, 0.9995201614F, -0.6731660801F, 0.739491331F, -0.7195018362F, -0.6944905383F, 0.9727511689F, 0.2318515979F, 0.9997059088F, -0.0242506907F, 0.4421787429F, -0.8969269532F, 0.9981350961F, -0.061043673F, -0.9173660799F, -0.3980445648F, -0.8150056635F, -0.5794529907F, -0.8789331304F, 0.4769450202F, 0.0158605829F, 0.999874213F, -0.8095464474F, 0.5870558317F, -0.9165898907F, -0.3998286786F, -0.8023542565F, 0.5968480938F, -0.5176737917F, 0.8555780767F, -0.8154407307F, -0.5788405779F, 0.4022010347F, -0.9155513791F, -0.9052556868F, -0.4248672045F, 0.7317445619F, 0.6815789728F, -0.5647632201F, -0.8252529947F, -0.8403276335F, -0.5420788397F, -0.9314281527F, 0.363925262F, 0.5238198472F, 0.8518290719F, 0.7432803869F, -0.6689800195F, -0.985371561F, -0.1704197369F, 0.4601468731F, 0.88784281F, 0.825855404F, 0.5638819483F, 0.6182366099F, 0.7859920446F, 0.8331502863F, -0.553046653F, 0.1500307506F, 0.9886813308F, -0.662330369F, -0.7492119075F, -0.668598664F, 0.743623444F, 0.7025606278F, 0.7116238924F, -0.5419389763F, -0.8404178401F, -0.3388616456F, 0.9408362159F, 0.8331530315F, 0.5530425174F, -0.2989720662F, -0.9542618632F, 0.2638522993F, 0.9645630949F, 0.124108739F, -0.9922686234F, -0.7282649308F, -0.6852956957F, 0.6962500149F, 0.7177993569F, -0.9183535368F, 0.3957610156F, -0.6326102274F, -0.7744703352F, -0.9331891859F, -0.359385508F, -0.1153779357F, -0.9933216659F, 0.9514974788F, -0.3076565421F, -0.08987977445F, -0.9959526224F, 0.6678496916F, 0.7442961705F, 0.7952400393F, -0.6062947138F, -0.6462007402F, -0.7631674805F, -0.2733598753F, 0.9619118351F, 0.9669590226F, -0.254931851F, -0.9792894595F, 0.2024651934F, -0.5369502995F, -0.8436138784F, -0.270036471F, -0.9628500944F, -0.6400277131F, 0.7683518247F, -0.7854537493F, -0.6189203566F, 0.06005905383F, -0.9981948257F, -0.02455770378F, 0.9996984141F, -0.65983623F, 0.751409442F, -0.6253894466F, -0.7803127835F, -0.6210408851F, -0.7837781695F, 0.8348888491F, 0.5504185768F, -0.1592275245F, 0.9872419133F, 0.8367622488F, 0.5475663786F, -0.8675753916F, -0.4973056806F, -0.2022662628F, -0.9793305667F, 0.9399189937F, 0.3413975472F, 0.9877404807F, -0.1561049093F, -0.9034455656F, 0.4287028224F, 0.1269804218F, -0.9919052235F, -0.3819600854F, 0.924178821F, 0.9754625894F, 0.2201652486F, -0.3204015856F, -0.9472818081F, -0.9874760884F, 0.1577687387F, 0.02535348474F, -0.9996785487F, 0.4835130794F, -0.8753371362F, -0.2850799925F, -0.9585037287F, -0.06805516006F, -0.99768156F, -0.7885244045F, -0.6150034663F, 0.3185392127F, -0.9479096845F, 0.8880043089F, 0.4598351306F, 0.6476921488F, -0.7619021462F, 0.9820241299F, 0.1887554194F, 0.9357275128F, -0.3527237187F, -0.8894895414F, 0.4569555293F, 0.7922791302F, 0.6101588153F, 0.7483818261F, 0.6632681526F, -0.7288929755F, -0.6846276581F, 0.8729032783F, -0.4878932944F, 0.8288345784F, 0.5594937369F, 0.08074567077F, 0.9967347374F, 0.9799148216F, -0.1994165048F, -0.580730673F, -0.8140957471F, -0.4700049791F, -0.8826637636F, 0.2409492979F, 0.9705377045F, 0.9437816757F, -0.3305694308F, -0.8927998638F, -0.4504535528F, -0.8069622304F, 0.5906030467F, 0.06258973166F, 0.9980393407F, -0.9312597469F, 0.3643559849F, 0.5777449785F, 0.8162173362F, -0.3360095855F, -0.941858566F, 0.697932075F, -0.7161639607F, -0.002008157227F, -0.9999979837F, -0.1827294312F, -0.9831632392F, -0.6523911722F, 0.7578824173F, -0.4302626911F, -0.9027037258F, -0.9985126289F, -0.05452091251F, -0.01028102172F, -0.9999471489F, -0.4946071129F, 0.8691166802F, -0.2999350194F, 0.9539596344F, 0.8165471961F, 0.5772786819F, 0.2697460475F, 0.962931498F, -0.7306287391F, -0.6827749597F, -0.7590952064F, -0.6509796216F, -0.907053853F, 0.4210146171F, -0.5104861064F, -0.8598860013F, 0.8613350597F, 0.5080373165F, 0.5007881595F, -0.8655698812F, -0.654158152F, 0.7563577938F, -0.8382755311F, -0.545246856F, 0.6940070834F, 0.7199681717F, 0.06950936031F, 0.9975812994F, 0.1702942185F, -0.9853932612F, 0.2695973274F, 0.9629731466F, 0.5519612192F, -0.8338697815F, 0.225657487F, -0.9742067022F, 0.4215262855F, -0.9068161835F, 0.4881873305F, -0.8727388672F, -0.3683854996F, -0.9296731273F, -0.9825390578F, 0.1860564427F, 0.81256471F, 0.5828709909F, 0.3196460933F, -0.9475370046F, 0.9570913859F, 0.2897862643F, -0.6876655497F, -0.7260276109F, -0.9988770922F, -0.047376731F, -0.1250179027F, 0.992154486F, -0.8280133617F, 0.560708367F, 0.9324863769F, -0.3612051451F, 0.6394653183F, 0.7688199442F, -0.01623847064F, -0.9998681473F, -0.9955014666F, -0.09474613458F, -0.81453315F, 0.580117012F, 0.4037327978F, -0.9148769469F, 0.9944263371F, 0.1054336766F, -0.1624711654F, 0.9867132919F, -0.9949487814F, -0.100383875F, -0.6995302564F, 0.7146029809F, 0.5263414922F, -0.85027327F, -0.5395221479F, 0.841971408F, 0.6579370318F, 0.7530729462F, 0.01426758847F, -0.9998982128F, -0.6734383991F, 0.7392433447F, 0.639412098F, -0.7688642071F, 0.9211571421F, 0.3891908523F, -0.146637214F, -0.9891903394F, -0.782318098F, 0.6228791163F, -0.5039610839F, -0.8637263605F, -0.7743120191F, -0.6328039957F, };
    private static final float[] GRADIENTS_3D = { 0, 1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, -1, 0, 1, 0, 1, 0, -1, 0, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, 1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, -1, 0, 0, 0, 1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, -1, 0, 1, 0, 1, 0, -1, 0, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, 1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, -1, 0, 0, 0, 1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, -1, 0, 1, 0, 1, 0, -1, 0, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, 1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, -1, 0, 0, 0, 1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, -1, 0, 1, 0, 1, 0, -1, 0, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, 1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, -1, 0, 0, 0, 1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, -1, 0, 1, 0, 1, 0, -1, 0, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, 1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, -1, 0, 0, 1, 1, 0, 0, 0, -1, 1, 0, -1, 1, 0, 0, 0, -1, -1, 0 };
    private static final float[] RAND_VECS_3D = { -0.7292736885F, -0.6618439697F, 0.1735581948F, 0, 0.790292081F, -0.5480887466F, -0.2739291014F, 0, 0.7217578935F, 0.6226212466F, -0.3023380997F, 0, 0.565683137F, -0.8208298145F, -0.0790000257F, 0, 0.760049034F, -0.5555979497F, -0.3370999617F, 0, 0.3713945616F, 0.5011264475F, 0.7816254623F, 0, -0.1277062463F, -0.4254438999F, -0.8959289049F, 0, -0.2881560924F, -0.5815838982F, 0.7607405838F, 0, 0.5849561111F, -0.662820239F, -0.4674352136F, 0, 0.3307171178F, 0.0391653737F, 0.94291689F, 0, 0.8712121778F, -0.4113374369F, -0.2679381538F, 0, 0.580981015F, 0.7021915846F, 0.4115677815F, 0, 0.503756873F, 0.6330056931F, -0.5878203852F, 0, 0.4493712205F, 0.601390195F, 0.6606022552F, 0, -0.6878403724F, 0.09018890807F, -0.7202371714F, 0, -0.5958956522F, -0.6469350577F, 0.475797649F, 0, -0.5127052122F, 0.1946921978F, -0.8361987284F, 0, -0.9911507142F, -0.05410276466F, -0.1212153153F, 0, -0.2149721042F, 0.9720882117F, -0.09397607749F, 0, -0.7518650936F, -0.5428057603F, 0.3742469607F, 0, 0.5237068895F, 0.8516377189F, -0.02107817834F, 0, 0.6333504779F, 0.1926167129F, -0.7495104896F, 0, -0.06788241606F, 0.3998305789F, 0.9140719259F, 0, -0.5538628599F, -0.4729896695F, -0.6852128902F, 0, -0.7261455366F, -0.5911990757F, 0.3509933228F, 0, -0.9229274737F, -0.1782808786F, 0.3412049336F, 0, -0.6968815002F, 0.6511274338F, 0.3006480328F, 0, 0.9608044783F, -0.2098363234F, -0.1811724921F, 0, 0.06817146062F, -0.9743405129F, 0.2145069156F, 0, -0.3577285196F, -0.6697087264F, -0.6507845481F, 0, -0.1868621131F, 0.7648617052F, -0.6164974636F, 0, -0.6541697588F, 0.3967914832F, 0.6439087246F, 0, 0.6993340405F, -0.6164538506F, 0.3618239211F, 0, -0.1546665739F, 0.6291283928F, 0.7617583057F, 0, -0.6841612949F, -0.2580482182F, -0.6821542638F, 0, 0.5383980957F, 0.4258654885F, 0.7271630328F, 0, -0.5026987823F, -0.7939832935F, -0.3418836993F, 0, 0.3202971715F, 0.2834415347F, 0.9039195862F, 0, 0.8683227101F, -0.0003762656404F, -0.4959995258F, 0, 0.791120031F, -0.08511045745F, 0.6057105799F, 0, -0.04011016052F, -0.4397248749F, 0.8972364289F, 0, 0.9145119872F, 0.3579346169F, -0.1885487608F, 0, -0.9612039066F, -0.2756484276F, 0.01024666929F, 0, 0.6510361721F, -0.2877799159F, -0.7023778346F, 0, -0.2041786351F, 0.7365237271F, 0.644859585F, 0, -0.7718263711F, 0.3790626912F, 0.5104855816F, 0, -0.3060082741F, -0.7692987727F, 0.5608371729F, 0, 0.454007341F, -0.5024843065F, 0.7357899537F, 0, 0.4816795475F, 0.6021208291F, -0.6367380315F, 0, 0.6961980369F, -0.3222197429F, 0.641469197F, 0, -0.6532160499F, -0.6781148932F, 0.3368515753F, 0, 0.5089301236F, -0.6154662304F, -0.6018234363F, 0, -0.1635919754F, -0.9133604627F, -0.372840892F, 0, 0.52408019F, -0.8437664109F, 0.1157505864F, 0, 0.5902587356F, 0.4983817807F, -0.6349883666F, 0, 0.5863227872F, 0.494764745F, 0.6414307729F, 0, 0.6779335087F, 0.2341345225F, 0.6968408593F, 0, 0.7177054546F, -0.6858979348F, 0.120178631F, 0, -0.5328819713F, -0.5205125012F, 0.6671608058F, 0, -0.8654874251F, -0.0700727088F, -0.4960053754F, 0, -0.2861810166F, 0.7952089234F, 0.5345495242F, 0, -0.04849529634F, 0.9810836427F, -0.1874115585F, 0, -0.6358521667F, 0.6058348682F, 0.4781800233F, 0, 0.6254794696F, -0.2861619734F, 0.7258696564F, 0, -0.2585259868F, 0.5061949264F, -0.8227581726F, 0, 0.02136306781F, 0.5064016808F, -0.8620330371F, 0, 0.200111773F, 0.8599263484F, 0.4695550591F, 0, 0.4743561372F, 0.6014985084F, -0.6427953014F, 0, 0.6622993731F, -0.5202474575F, -0.5391679918F, 0, 0.08084972818F, -0.6532720452F, 0.7527940996F, 0, -0.6893687501F, 0.0592860349F, 0.7219805347F, 0, -0.1121887082F, -0.9673185067F, 0.2273952515F, 0, 0.7344116094F, 0.5979668656F, -0.3210532909F, 0, 0.5789393465F, -0.2488849713F, 0.7764570201F, 0, 0.6988182827F, 0.3557169806F, -0.6205791146F, 0, -0.8636845529F, -0.2748771249F, -0.4224826141F, 0, -0.4247027957F, -0.4640880967F, 0.777335046F, 0, 0.5257722489F, -0.8427017621F, 0.1158329937F, 0, 0.9343830603F, 0.316302472F, -0.1639543925F, 0, -0.1016836419F, -0.8057303073F, -0.5834887393F, 0, -0.6529238969F, 0.50602126F, -0.5635892736F, 0, -0.2465286165F, -0.9668205684F, -0.06694497494F, 0, -0.9776897119F, -0.2099250524F, -0.007368825344F, 0, 0.7736893337F, 0.5734244712F, 0.2694238123F, 0, -0.6095087895F, 0.4995678998F, 0.6155736747F, 0, 0.5794535482F, 0.7434546771F, 0.3339292269F, 0, -0.8226211154F, 0.08142581855F, 0.5627293636F, 0, -0.510385483F, 0.4703667658F, 0.7199039967F, 0, -0.5764971849F, -0.07231656274F, -0.8138926898F, 0, 0.7250628871F, 0.3949971505F, -0.5641463116F, 0, -0.1525424005F, 0.4860840828F, -0.8604958341F, 0, -0.5550976208F, -0.4957820792F, 0.667882296F, 0, -0.1883614327F, 0.9145869398F, 0.357841725F, 0, 0.7625556724F, -0.5414408243F, -0.3540489801F, 0, -0.5870231946F, -0.3226498013F, -0.7424963803F, 0, 0.3051124198F, 0.2262544068F, -0.9250488391F, 0, 0.6379576059F, 0.577242424F, -0.5097070502F, 0, -0.5966775796F, 0.1454852398F, -0.7891830656F, 0, -0.658330573F, 0.6555487542F, -0.3699414651F, 0, 0.7434892426F, 0.2351084581F, 0.6260573129F, 0, 0.5562114096F, 0.8264360377F, -0.0873632843F, 0, -0.3028940016F, -0.8251527185F, 0.4768419182F, 0, 0.1129343818F, -0.985888439F, -0.1235710781F, 0, 0.5937652891F, -0.5896813806F, 0.5474656618F, 0, 0.6757964092F, -0.5835758614F, -0.4502648413F, 0, 0.7242302609F, -0.1152719764F, 0.6798550586F, 0, -0.9511914166F, 0.0753623979F, -0.2992580792F, 0, 0.2539470961F, -0.1886339355F, 0.9486454084F, 0, 0.571433621F, -0.1679450851F, -0.8032795685F, 0, -0.06778234979F, 0.3978269256F, 0.9149531629F, 0, 0.6074972649F, 0.733060024F, -0.3058922593F, 0, -0.5435478392F, 0.1675822484F, 0.8224791405F, 0, -0.5876678086F, -0.3380045064F, -0.7351186982F, 0, -0.7967562402F, 0.04097822706F, -0.6029098428F, 0, -0.1996350917F, 0.8706294745F, 0.4496111079F, 0, -0.02787660336F, -0.9106232682F, -0.4122962022F, 0, -0.7797625996F, -0.6257634692F, 0.01975775581F, 0, -0.5211232846F, 0.7401644346F, -0.4249554471F, 0, 0.8575424857F, 0.4053272873F, -0.3167501783F, 0, 0.1045223322F, 0.8390195772F, -0.5339674439F, 0, 0.3501822831F, 0.9242524096F, -0.1520850155F, 0, 0.1987849858F, 0.07647613266F, 0.9770547224F, 0, 0.7845996363F, 0.6066256811F, -0.1280964233F, 0, 0.09006737436F, -0.9750989929F, -0.2026569073F, 0, -0.8274343547F, -0.542299559F, 0.1458203587F, 0, -0.3485797732F, -0.415802277F, 0.840000362F, 0, -0.2471778936F, -0.7304819962F, -0.6366310879F, 0, -0.3700154943F, 0.8577948156F, 0.3567584454F, 0, 0.5913394901F, -0.548311967F, -0.5913303597F, 0, 0.1204873514F, -0.7626472379F, -0.6354935001F, 0, 0.616959265F, 0.03079647928F, 0.7863922953F, 0, 0.1258156836F, -0.6640829889F, -0.7369967419F, 0, -0.6477565124F, -0.1740147258F, -0.7417077429F, 0, 0.6217889313F, -0.7804430448F, -0.06547655076F, 0, 0.6589943422F, -0.6096987708F, 0.4404473475F, 0, -0.2689837504F, -0.6732403169F, -0.6887635427F, 0, -0.3849775103F, 0.5676542638F, 0.7277093879F, 0, 0.5754444408F, 0.8110471154F, -0.1051963504F, 0, 0.9141593684F, 0.3832947817F, 0.131900567F, 0, -0.107925319F, 0.9245493968F, 0.3654593525F, 0, 0.377977089F, 0.3043148782F, 0.8743716458F, 0, -0.2142885215F, -0.8259286236F, 0.5214617324F, 0, 0.5802544474F, 0.4148098596F, -0.7008834116F, 0, -0.1982660881F, 0.8567161266F, -0.4761596756F, 0, -0.03381553704F, 0.3773180787F, -0.9254661404F, 0, -0.6867922841F, -0.6656597827F, 0.2919133642F, 0, 0.7731742607F, -0.2875793547F, -0.5652430251F, 0, -0.09655941928F, 0.9193708367F, -0.3813575004F, 0, 0.2715702457F, -0.9577909544F, -0.09426605581F, 0, 0.2451015704F, -0.6917998565F, -0.6792188003F, 0, 0.977700782F, -0.1753855374F, 0.1155036542F, 0, -0.5224739938F, 0.8521606816F, 0.02903615945F, 0, -0.7734880599F, -0.5261292347F, 0.3534179531F, 0, -0.7134492443F, -0.269547243F, 0.6467878011F, 0, 0.1644037271F, 0.5105846203F, -0.8439637196F, 0, 0.6494635788F, 0.05585611296F, 0.7583384168F, 0, -0.4711970882F, 0.5017280509F, -0.7254255765F, 0, -0.6335764307F, -0.2381686273F, -0.7361091029F, 0, -0.9021533097F, -0.270947803F, -0.3357181763F, 0, -0.3793711033F, 0.872258117F, 0.3086152025F, 0, -0.6855598966F, -0.3250143309F, 0.6514394162F, 0, 0.2900942212F, -0.7799057743F, -0.5546100667F, 0, -0.2098319339F, 0.85037073F, 0.4825351604F, 0, -0.4592603758F, 0.6598504336F, -0.5947077538F, 0, 0.8715945488F, 0.09616365406F, -0.4807031248F, 0, -0.6776666319F, 0.7118504878F, -0.1844907016F, 0, 0.7044377633F, 0.312427597F, 0.637304036F, 0, -0.7052318886F, -0.2401093292F, -0.6670798253F, 0, 0.081921007F, -0.7207336136F, -0.6883545647F, 0, -0.6993680906F, -0.5875763221F, -0.4069869034F, 0, -0.1281454481F, 0.6419895885F, 0.7559286424F, 0, -0.6337388239F, -0.6785471501F, -0.3714146849F, 0, 0.5565051903F, -0.2168887573F, -0.8020356851F, 0, -0.5791554484F, 0.7244372011F, -0.3738578718F, 0, 0.1175779076F, -0.7096451073F, 0.6946792478F, 0, -0.6134619607F, 0.1323631078F, 0.7785527795F, 0, 0.6984635305F, -0.02980516237F, -0.715024719F, 0, 0.8318082963F, -0.3930171956F, 0.3919597455F, 0, 0.1469576422F, 0.05541651717F, -0.9875892167F, 0, 0.708868575F, -0.2690503865F, 0.6520101478F, 0, 0.2726053183F, 0.67369766F, -0.68688995F, 0, -0.6591295371F, 0.3035458599F, -0.6880466294F, 0, 0.4815131379F, -0.7528270071F, 0.4487723203F, 0, 0.9430009463F, 0.1675647412F, -0.2875261255F, 0, 0.434802957F, 0.7695304522F, -0.4677277752F, 0, 0.3931996188F, 0.594473625F, 0.7014236729F, 0, 0.7254336655F, -0.603925654F, 0.3301814672F, 0, 0.7590235227F, -0.6506083235F, 0.02433313207F, 0, -0.8552768592F, -0.3430042733F, 0.3883935666F, 0, -0.6139746835F, 0.6981725247F, 0.3682257648F, 0, -0.7465905486F, -0.5752009504F, 0.3342849376F, 0, 0.5730065677F, 0.810555537F, -0.1210916791F, 0, -0.9225877367F, -0.3475211012F, -0.167514036F, 0, -0.7105816789F, -0.4719692027F, -0.5218416899F, 0, -0.08564609717F, 0.3583001386F, 0.929669703F, 0, -0.8279697606F, -0.2043157126F, 0.5222271202F, 0, 0.427944023F, 0.278165994F, 0.8599346446F, 0, 0.5399079671F, -0.7857120652F, -0.3019204161F, 0, 0.5678404253F, -0.5495413974F, -0.6128307303F, 0, -0.9896071041F, 0.1365639107F, -0.04503418428F, 0, -0.6154342638F, -0.6440875597F, 0.4543037336F, 0, 0.1074204368F, -0.7946340692F, 0.5975094525F, 0, -0.3595449969F, -0.8885529948F, 0.28495784F, 0, -0.2180405296F, 0.1529888965F, 0.9638738118F, 0, -0.7277432317F, -0.6164050508F, -0.3007234646F, 0, 0.7249729114F, -0.00669719484F, 0.6887448187F, 0, -0.5553659455F, -0.5336586252F, 0.6377908264F, 0, 0.5137558015F, 0.7976208196F, -0.3160000073F, 0, -0.3794024848F, 0.9245608561F, -0.03522751494F, 0, 0.8229248658F, 0.2745365933F, -0.4974176556F, 0, -0.5404114394F, 0.6091141441F, 0.5804613989F, 0, 0.8036581901F, -0.2703029469F, 0.5301601931F, 0, 0.6044318879F, 0.6832968393F, 0.4095943388F, 0, 0.06389988817F, 0.9658208605F, -0.2512108074F, 0, 0.1087113286F, 0.7402471173F, -0.6634877936F, 0, -0.713427712F, -0.6926784018F, 0.1059128479F, 0, 0.6458897819F, -0.5724548511F, -0.5050958653F, 0, -0.6553931414F, 0.7381471625F, 0.159995615F, 0, 0.3910961323F, 0.9188871375F, -0.05186755998F, 0, -0.4879022471F, -0.5904376907F, 0.6429111375F, 0, 0.6014790094F, 0.7707441366F, -0.2101820095F, 0, -0.5677173047F, 0.7511360995F, 0.3368851762F, 0, 0.7858573506F, 0.226674665F, 0.5753666838F, 0, -0.4520345543F, -0.604222686F, -0.6561857263F, 0, 0.002272116345F, 0.4132844051F, -0.9105991643F, 0, -0.5815751419F, -0.5162925989F, 0.6286591339F, 0, -0.03703704785F, 0.8273785755F, 0.5604221175F, 0, -0.5119692504F, 0.7953543429F, -0.3244980058F, 0, -0.2682417366F, -0.9572290247F, -0.1084387619F, 0, -0.2322482736F, -0.9679131102F, -0.09594243324F, 0, 0.3554328906F, -0.8881505545F, 0.2913006227F, 0, 0.7346520519F, -0.4371373164F, 0.5188422971F, 0, 0.9985120116F, 0.04659011161F, -0.02833944577F, 0, -0.3727687496F, -0.9082481361F, 0.1900757285F, 0, 0.91737377F, -0.3483642108F, 0.1925298489F, 0, 0.2714911074F, 0.4147529736F, -0.8684886582F, 0, 0.5131763485F, -0.7116334161F, 0.4798207128F, 0, -0.8737353606F, 0.18886992F, -0.4482350644F, 0, 0.8460043821F, -0.3725217914F, 0.3814499973F, 0, 0.8978727456F, -0.1780209141F, -0.4026575304F, 0, 0.2178065647F, -0.9698322841F, -0.1094789531F, 0, -0.1518031304F, -0.7788918132F, -0.6085091231F, 0, -0.2600384876F, -0.4755398075F, -0.8403819825F, 0, 0.572313509F, -0.7474340931F, -0.3373418503F, 0, -0.7174141009F, 0.1699017182F, -0.6756111411F, 0, -0.684180784F, 0.02145707593F, -0.7289967412F, 0, -0.2007447902F, 0.06555605789F, -0.9774476623F, 0, -0.1148803697F, -0.8044887315F, 0.5827524187F, 0, -0.7870349638F, 0.03447489231F, 0.6159443543F, 0, -0.2015596421F, 0.6859872284F, 0.6991389226F, 0, -0.08581082512F, -0.10920836F, -0.9903080513F, 0, 0.5532693395F, 0.7325250401F, -0.396610771F, 0, -0.1842489331F, -0.9777375055F, -0.1004076743F, 0, 0.0775473789F, -0.9111505856F, 0.4047110257F, 0, 0.1399838409F, 0.7601631212F, -0.6344734459F, 0, 0.4484419361F, -0.845289248F, 0.2904925424F, 0 };

    // Hashing
    private static final int PRIME_X = 501125321;
    private static final int PRIME_Y = 1136930381;
    private static final int PRIME_Z = 1720413743;

    public enum NoiseType {
        OPEN_SIMPLEX_2,
        OPEN_SIMPLEX_2S,
        CELLULAR,
        PERLIN,
        VALUE_CUBIC,
        VALUE
    }

    public enum RotationType3D {
        NONE,
        IMPROVE_XY_PLANES,
        IMPROVE_XZ_PLANES
    }

    public enum FractalType {
        NONE,
        FBM,
        RIDGED,
        PING_PONG,
        DOMAIN_WARP_PROGRESSIVE,
        DOMAIN_WARP_INDEPENDENT
    }

    public enum CellularDistFunc {
        EUCLIDEAN,
        EUCLIDEAN_SQ,
        MANHATTAN,
        HYBRID
    }

    public enum CellularReturnType {
        CELL_VALUE,
        DIST,
        DIST_2,
        DIST_2_ADD,
        DIST_2_SUB,
        DIST_2_MUL,
        DIST_2_DIV
    }

    public enum DomainWarpType {
        OPEN_SIMPLEX_2,
        OPEN_SIMPLEX_2_REDUCED,
        BASIC_GRID
    }

    private enum TransformType3D {
        NONE,
        IMPROVE_XY_PLANES,
        IMPROVE_XZ_PLANES,
        DEFAULT_OPEN_SIMPLEX_2
    }


    private int seed = 1337;
    private float frequency = 0.01F;
    private NoiseType noiseType = NoiseType.OPEN_SIMPLEX_2;
    private RotationType3D rotationType3D = RotationType3D.NONE;
    private TransformType3D transformType3D = TransformType3D.DEFAULT_OPEN_SIMPLEX_2;

    private FractalType fractalType = FractalType.NONE;
    private int octaves = 3;
    private float lacunarity = 2F;
    private float gain = 0.5F;
    private float weightedStrength = 0F;
    private float pingPongStrength = 2F;

    private float fractalBounding = 1 / 1.75F;

    private CellularDistFunc cellularDistFunc = CellularDistFunc.EUCLIDEAN_SQ;
    private CellularReturnType cellularReturnType = CellularReturnType.DIST;
    private float cellularJitterModifier = 1F;

    private DomainWarpType domainWarpType = DomainWarpType.OPEN_SIMPLEX_2;
    private TransformType3D warpTransformType3D = TransformType3D.DEFAULT_OPEN_SIMPLEX_2;
    private float domainWarpAmp = 1F;

    public FastNoise() { }

    public FastNoise(int seed) {
        setSeed(seed);
    }


    public FastNoise setSeed(int seed) {
        this.seed = seed;
        return this;
    }

    public FastNoise setFrequency(float frequency) {
        this.frequency = frequency;
        return this;
    }

    public FastNoise setNoiseType(NoiseType noiseType) {
        this.noiseType = noiseType;
        updateTransformType3D();
        return this;
    }

    public FastNoise setRotationType3D(RotationType3D rotationType3D) {
        this.rotationType3D = rotationType3D;
        updateWarpTransformType3D();
        updateTransformType3D();
        return this;
    }

    public FastNoise setFractalType(FractalType fractalType) {
        this.fractalType = fractalType;
        return this;
    }

    public FastNoise setFractalOctaves(int octaves) {
        this.octaves = octaves;
        calculateFractalBounding();
        return this;
    }

    public FastNoise setFractalLacunarity(float lacunarity) {
        this.lacunarity = lacunarity;
        return this;
    }

    public FastNoise setFractalGain(float gain) {
        this.gain = gain;
        calculateFractalBounding();
        return this;
    }

    public FastNoise setFractalWeightedStrength(float weightedStrength) {
        this.weightedStrength = weightedStrength;
        return this;
    }

    public FastNoise setFractalPingPongStrength(float pingPongStrength) {
        this.pingPongStrength = pingPongStrength;
        return this;
    }

    public FastNoise setCellularDistanceFunction(CellularDistFunc cellularDistFunc) {
        this.cellularDistFunc = cellularDistFunc;
        return this;
    }

    public FastNoise setCellularReturnType(CellularReturnType cellularReturnType) {
        this.cellularReturnType = cellularReturnType;
        return this;
    }

    public FastNoise setCellularJitter(float cellularJitter) {
        cellularJitterModifier = cellularJitter;
        return this;
    }

    public FastNoise setDomainWarpType(DomainWarpType domainWarpType) {
        this.domainWarpType = domainWarpType;
        updateWarpTransformType3D();
        return this;
    }

    public FastNoise setDomainWarpAmp(float domainWarpAmp) {
        this.domainWarpAmp = domainWarpAmp;
        return this;
    }


    /**
     * 2D noise at given position using current settings
     * Noise output bounded between -1...1
     */
    public float get(float x, float y) {
        x *= frequency;
        y *= frequency;

        switch(noiseType) {
            case OPEN_SIMPLEX_2:
            case OPEN_SIMPLEX_2S: {
                final float F2 = 0.5F * (Maths.SQRT3 - 1);
                final float t = (x + y) * F2;
                x += t;
                y += t;
            }
        }

        switch(fractalType) {
            case FBM: return genFractalFbm(x, y);
            case RIDGED: return genFractalRidged(x, y);
            case PING_PONG: return genFractalPingPong(x, y);
            default: return genNoiseSingle(seed, x, y);
        }
    }

    /**
     * 2D noise at given position using current settings
     * Noise output bounded between 0...1
     */
    public float getNorm(float x, float y) {
        return (get(x, y) + 1) * 0.5F;
    }

    /**
     * 3D noise at given position using current settings
     * Noise output bounded between -1...1
     */
    public float get(float x, float y, float z) {
        x *= frequency;
        y *= frequency;
        z *= frequency;

        switch(transformType3D){
            case IMPROVE_XY_PLANES: {
                final float xy = x + y;
                final float s2 = xy * -0.211324865405187F;
                z *= 0.577350269189626F;
                x += s2 - z;
                y = y + s2 - z;
                z += xy * 0.577350269189626F;
                break;
            }
            case IMPROVE_XZ_PLANES: {
                final float xz = x + z;
                final float s2 = xz * -0.211324865405187F;
                y *= 0.577350269189626F;
                x += s2 - y;
                z += s2 - y;
                y += xz * 0.577350269189626F;
                break;
            }
            case DEFAULT_OPEN_SIMPLEX_2: {
                final float R3 = TWO_THIRDS;
                final float r = (x + y + z) * R3; // Rotation, not skew
                x = r - x;
                y = r - y;
                z = r - z;
                break;
            }
        }

        switch(fractalType){
            case FBM: return genFractalFbm(x, y, z);
            case RIDGED: return genFractalRidged(x, y, z);
            case PING_PONG: return genFractalPingPong(x, y, z);
            default: return genNoiseSingle(seed, x, y, z);
        }
    }

    /**
     * 3D noise at given position using current settings
     * Noise output bounded between 0...1
     */
    public float getNorm(float x, float y, float z) {
        return (get(x, y, z) + 1) * 0.5F;
    }

    /**
     * 2D warps the input position using current domain warp settings
     * Example usage with get
     * <code>domainWarp(coord)
     * noise = get(x, y)</code>
     */
    public void domainWarp(Vec2f coord) {
        switch(fractalType){
            case DOMAIN_WARP_PROGRESSIVE: {
                domainWarpFractalProgressive(coord);
                break;
            }
            case DOMAIN_WARP_INDEPENDENT: {
                domainWarpFractalIndependent(coord);
                break;
            }
            default: domainWarpSingle(coord);
        }
    }

    /**
     * 3D warps the input position using current domain warp settings
     * Example usage with get
     * <code>domainWarp(coord)
     * noise = get(x, y, z)</code>
     */
    public void domainWarp(Vec3f coord) {
        switch(fractalType){
            case DOMAIN_WARP_PROGRESSIVE: {
                domainWarpFractalProgressive(coord);
                break;
            }
            case DOMAIN_WARP_INDEPENDENT: {
                domainWarpFractalIndependent(coord);
                break;
            }
            default: domainWarpSingle(coord);
        }
    }

    public static float pingPong(float t) {
        t -= (int) (t * 0.5) * 2;
        return (t < 1) ? t : (2 - t);
    }

    private void calculateFractalBounding() {
        final float gain = Math.abs(this.gain);
        float amp = gain;
        float ampFractal = 1F;
        for(int i = 1; i < octaves; i++){
            ampFractal += amp;
            amp *= gain;
        }
        fractalBounding = 1 / ampFractal;
    }

    private static int hash(int seed, int xPrimed, int yPrimed) {
        return (seed ^ xPrimed ^ yPrimed) * 0x27d4eb2d;
    }

    private static int hash(int seed, int xPrimed, int yPrimed, int zPrimed) {
        return (seed ^ xPrimed ^ yPrimed ^ zPrimed) * 0x27d4eb2d;
    }

    private static float valCoord(int seed, int xPrimed, int yPrimed) {
        int hash = hash(seed, xPrimed, yPrimed);
        hash *= hash;
        hash ^= hash << 19;
        return hash * (1 / 2147483648F);
    }

    private static float valCoord(int seed, int xPrimed, int yPrimed, int zPrimed) {
        int hash = hash(seed, xPrimed, yPrimed, zPrimed);
        hash *= hash;
        hash ^= hash << 19;
        return hash * (1 / 2147483648F);
    }

    private static float gradCoord(int seed, int xPrimed, int yPrimed, float xd, float yd) {
        int hash = hash(seed, xPrimed, yPrimed);
        hash ^= hash >> 15;
        hash &= 127 << 1;

        final float xg = GRADIENTS_2D[hash];
        final float yg = GRADIENTS_2D[hash | 1];
        return xd * xg + yd * yg;
    }

    private static float gradCoord(int seed, int xPrimed, int yPrimed, int zPrimed, float xd, float yd, float zd) {
        int hash = hash(seed, xPrimed, yPrimed, zPrimed);
        hash ^= hash >> 15;
        hash &= 63 << 2;

        final float xg = GRADIENTS_3D[hash];
        final float yg = GRADIENTS_3D[hash | 1];
        final float zg = GRADIENTS_3D[hash | 2];
        return xd * xg + yd * yg + zd * zg;
    }


    // Generic Noise Gen

    private float genNoiseSingle(int seed, float x, float y) {
        switch(noiseType){
            case OPEN_SIMPLEX_2: return singleSimplex(seed, x, y);
            case OPEN_SIMPLEX_2S: return singleOpenSimplex2S(seed, x, y);
            case CELLULAR: return singleCellular(seed, x, y);
            case PERLIN: return singlePerlin(seed, x, y);
            case VALUE_CUBIC: return singleValueCubic(seed, x, y);
            case VALUE: return singleValue(seed, x, y);
        }
        return 0F; // old switch syntax issue
    }

    private float genNoiseSingle(int seed, float x, float y, float z) {
        switch(noiseType){
            case OPEN_SIMPLEX_2: return singleOpenSimplex2(seed, x, y, z);
            case OPEN_SIMPLEX_2S: return singleOpenSimplex2S(seed, x, y, z);
            case CELLULAR: return singleCellular(seed, x, y, z);
            case PERLIN: return singlePerlin(seed, x, y, z);
            case VALUE_CUBIC: return singleValueCubic(seed, x, y, z);
            case VALUE: return singleValue(seed, x, y, z);
        }
        return 0F; // old switch syntax issue
    }


    // Noise Coordinate Transforms (frequency, and possible skew or rotation)

    private void updateTransformType3D() {
        switch(rotationType3D){
            case IMPROVE_XY_PLANES: {
                transformType3D = TransformType3D.IMPROVE_XY_PLANES;
                break;
            }
            case IMPROVE_XZ_PLANES: {
                transformType3D = TransformType3D.IMPROVE_XZ_PLANES;
                break;
            }
            default: {
                switch(noiseType){
                    case OPEN_SIMPLEX_2:
                    case OPEN_SIMPLEX_2S: {
                        transformType3D = TransformType3D.DEFAULT_OPEN_SIMPLEX_2;
                        break;
                    }
                    default: transformType3D = TransformType3D.NONE;
                }
            }
        }
    }

    private void updateWarpTransformType3D() {
        switch(rotationType3D){
            case IMPROVE_XY_PLANES: {
                warpTransformType3D = TransformType3D.IMPROVE_XY_PLANES;
                break;
            }
            case IMPROVE_XZ_PLANES: {
                warpTransformType3D = TransformType3D.IMPROVE_XZ_PLANES;
                break;
            }
            default: {
                switch(domainWarpType){
                    case OPEN_SIMPLEX_2:
                    case OPEN_SIMPLEX_2_REDUCED: {
                        warpTransformType3D = TransformType3D.DEFAULT_OPEN_SIMPLEX_2;
                        break;
                    }
                    default: warpTransformType3D = TransformType3D.NONE;
                }
            }
        }
    }


    // Fractal Fbm

    private float genFractalFbm(float x, float y) {
        int seed = this.seed;
        float sum = 0;
        float amp = fractalBounding;

        for(int i = 0; i < octaves; i++){
            final float noise = genNoiseSingle(seed++, x, y);
            sum += noise * amp;
            amp *= Maths.lerp(1F, Math.min(noise + 1, 2) * 0.5F, weightedStrength);

            x *= lacunarity;
            y *= lacunarity;
            amp *= gain;
        }

        return sum;
    }

    private float genFractalFbm(float x, float y, float z) {
        int seed = this.seed;
        float sum = 0;
        float amp = fractalBounding;

        for(int i = 0; i < octaves; i++){
            final float noise = genNoiseSingle(seed++, x, y, z);
            sum += noise * amp;
            amp *= Maths.lerp(1F, (noise + 1) * 0.5F, weightedStrength);

            x *= lacunarity;
            y *= lacunarity;
            z *= lacunarity;
            amp *= gain;
        }

        return sum;
    }


    // Fractal Ridged

    private float genFractalRidged(float x, float y) {
        int seed = this.seed;
        float sum = 0;
        float amp = fractalBounding;

        for(int i = 0; i < octaves; i++){
            final float noise = Math.abs(genNoiseSingle(seed++, x, y));
            sum += (noise * -2 + 1) * amp;
            amp *= Maths.lerp(1F, 1 - noise, weightedStrength);

            x *= lacunarity;
            y *= lacunarity;
            amp *= gain;
        }

        return sum;
    }

    private float genFractalRidged(float x, float y, float z) {
        int seed = this.seed;
        float sum = 0;
        float amp = fractalBounding;

        for(int i = 0; i < octaves; i++){
            final float noise = Math.abs(genNoiseSingle(seed++, x, y, z));
            sum += (noise * -2 + 1) * amp;
            amp *= Maths.lerp(1F, 1 - noise, weightedStrength);

            x *= lacunarity;
            y *= lacunarity;
            z *= lacunarity;
            amp *= gain;
        }

        return sum;
    }


    // Fractal PingPong

    private float genFractalPingPong(float x, float y) {
        int seed = this.seed;
        float sum = 0;
        float amp = fractalBounding;

        for(int i = 0; i < octaves; i++){
            final float noise = pingPong((genNoiseSingle(seed++, x, y) + 1) * pingPongStrength);
            sum += (noise - 0.5F) * 2 * amp;
            amp *= Maths.lerp(1F, noise, weightedStrength);

            x *= lacunarity;
            y *= lacunarity;
            amp *= gain;
        }

        return sum;
    }

    private float genFractalPingPong(float x, float y, float z) {
        int seed = this.seed;
        float sum = 0;
        float amp = fractalBounding;

        for(int i = 0; i < octaves; i++){
            float noise = pingPong((genNoiseSingle(seed++, x, y, z) + 1) * pingPongStrength);
            sum += (noise - 0.5F) * 2 * amp;
            amp *= Maths.lerp(1F, noise, weightedStrength);

            x *= lacunarity;
            y *= lacunarity;
            z *= lacunarity;
            amp *= gain;
        }

        return sum;
    }


    // Simplex/OpenSimplex2 Noise

    private float singleSimplex(int seed, float x, float y) {
        // 2D OpenSimplex2 case uses the same algorithm as ordinary Simplex.

        final float G2 = (3 - Maths.SQRT3) / 6;

        // Skew moved to switch statements before fractal evaluation

        int i = Maths.floor(x);
        int j = Maths.floor(y);
        float xi = (x - i);
        float yi = (y - j);

        float t = (xi + yi) * G2;
        float x0 = (xi - t);
        float y0 = (yi - t);

        i *= PRIME_X;
        j *= PRIME_Y;

        float n0, n1, n2;

        float a = 0.5F - x0 * x0 - y0 * y0;
        if(a <= 0)
            n0 = 0;
        else{
            n0 = (a * a) * (a * a) * gradCoord(seed, i, j, x0, y0);
        }

        float c = (2 * (1 - 2 * G2) * (1 / G2 - 2)) * t + ((-2 * (1 - 2 * G2) * (1 - 2 * G2)) + a);
        if(c <= 0)
            n2 = 0;
        else{
            float x2 = x0 + (2 * G2 - 1);
            float y2 = y0 + (2 * G2 - 1);
            n2 = (c * c) * (c * c) * gradCoord(seed, i + PRIME_X, j + PRIME_Y, x2, y2);
        }

        if(y0 > x0){
            float x1 = x0 + G2;
            float y1 = y0 + (G2 - 1);
            float b = 0.5F - x1 * x1 - y1 * y1;
            if(b <= 0)
                n1 = 0;
            else{
                n1 = (b * b) * (b * b) * gradCoord(seed, i, j + PRIME_Y, x1, y1);
            }
        }else{
            float x1 = x0 + (G2 - 1);
            float y1 = y0 + G2;
            float b = 0.5F - x1 * x1 - y1 * y1;
            if(b <= 0)
                n1 = 0;
            else{
                n1 = (b * b) * (b * b) * gradCoord(seed, i + PRIME_X, j, x1, y1);
            }
        }

        return (n0 + n1 + n2) * 99.83685446303647F;
    }

    private float singleOpenSimplex2(int seed, float x, float y, float z) {
        // 3D OpenSimplex2 case uses two offset rotated cube grids.
        // Rotation moved to switch statements before fractal evaluation

        int i = Maths.round(x);
        int j = Maths.round(y);
        int k = Maths.round(z);
        float x0 = (x - i);
        float y0 = (y - j);
        float z0 = (z - k);

        int xNSign = (int) (-1F - x0) | 1;
        int yNSign = (int) (-1F - y0) | 1;
        int zNSign = (int) (-1F - z0) | 1;

        float ax0 = xNSign * -x0;
        float ay0 = yNSign * -y0;
        float az0 = zNSign * -z0;

        i *= PRIME_X;
        j *= PRIME_Y;
        k *= PRIME_Z;

        float value = 0;
        float a = (0.6F - x0 * x0) - (y0 * y0 + z0 * z0);

        for(int l = 0; ; l++){
            if(a > 0){
                value += (a * a) * (a * a) * gradCoord(seed, i, j, k, x0, y0, z0);
            }

            if(ax0 >= ay0 && ax0 >= az0){
                float b = a + ax0 + ax0;
                if(b > 1){
                    b -= 1;
                    value += (b * b) * (b * b) * gradCoord(seed, i - xNSign * PRIME_X, j, k, x0 + xNSign, y0, z0);
                }
            }else if(ay0 > ax0 && ay0 >= az0){
                float b = a + ay0 + ay0;
                if(b > 1){
                    b -= 1;
                    value += (b * b) * (b * b) * gradCoord(seed, i, j - yNSign * PRIME_Y, k, x0, y0 + yNSign, z0);
                }
            }else{
                float b = a + az0 + az0;
                if(b > 1){
                    b -= 1;
                    value += (b * b) * (b * b) * gradCoord(seed, i, j, k - zNSign * PRIME_Z, x0, y0, z0 + zNSign);
                }
            }

            if(l == 1)
                break;

            ax0 = 0.5F - ax0;
            ay0 = 0.5F - ay0;
            az0 = 0.5F - az0;

            x0 = xNSign * ax0;
            y0 = yNSign * ay0;
            z0 = zNSign * az0;

            a += (0.75F - ax0) - (ay0 + az0);

            i += (xNSign >> 1) & PRIME_X;
            j += (yNSign >> 1) & PRIME_Y;
            k += (zNSign >> 1) & PRIME_Z;

            xNSign = -xNSign;
            yNSign = -yNSign;
            zNSign = -zNSign;

            seed = ~seed;
        }

        return value * 32.69428253173828125F;
    }


    // OpenSimplex2S Noise

    private float singleOpenSimplex2S(int seed, float x, float y) {
        // 2D OpenSimplex2S case is a modified 2D simplex noise.

        final float G2 = (3 - Maths.SQRT3) / 6;

        // Skew moved to TransformNoiseCoordinate method

        int i = Maths.floor(x);
        int j = Maths.floor(y);
        float xi = (x - i);
        float yi = (y - j);

        i *= PRIME_X;
        j *= PRIME_Y;
        int i1 = i + PRIME_X;
        int j1 = j + PRIME_Y;

        float t = (xi + yi) * G2;
        float x0 = xi - t;
        float y0 = yi - t;

        float a0 = TWO_THIRDS - x0 * x0 - y0 * y0;
        float value = (a0 * a0) * (a0 * a0) * gradCoord(seed, i, j, x0, y0);

        float a1 = (2 * (1 - 2 * G2) * (1 / G2 - 2)) * t + ((-2 * (1 - 2 * G2) * (1 - 2 * G2)) + a0);
        float x1 = x0 - (1 - 2 * G2);
        float y1 = y0 - (1 - 2 * G2);
        value += (a1 * a1) * (a1 * a1) * gradCoord(seed, i1, j1, x1, y1);

        // Nested conditionals were faster than compact bit logic/arithmetic.
        float xmyi = xi - yi;
        if(t > G2){
            if(xi + xmyi > 1){
                float x2 = x0 + (3 * G2 - 2);
                float y2 = y0 + (3 * G2 - 1);
                float a2 = TWO_THIRDS - x2 * x2 - y2 * y2;
                if(a2 > 0)
                    value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i + (PRIME_X << 1), j + PRIME_Y, x2, y2);
            }else{
                float x2 = x0 + G2;
                float y2 = y0 + (G2 - 1);
                float a2 = TWO_THIRDS - x2 * x2 - y2 * y2;
                if(a2 > 0)
                    value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i, j + PRIME_Y, x2, y2);
            }

            if(yi - xmyi > 1){
                float x3 = x0 + (3 * G2 - 1);
                float y3 = y0 + (3 * G2 - 2);
                float a3 = TWO_THIRDS - x3 * x3 - y3 * y3;
                if(a3 > 0){
                    final float grad = gradCoord(seed, i + PRIME_X, j + (PRIME_Y << 1), x3, y3);
                    value += a3 * a3 * a3 * a3 * grad;
                }
            }else{
                float x3 = x0 + (G2 - 1);
                float y3 = y0 + G2;
                float a3 = TWO_THIRDS - x3 * x3 - y3 * y3;
                if(a3 > 0)
                    value += (a3 * a3) * (a3 * a3) * gradCoord(seed, i + PRIME_X, j, x3, y3);
            }
        }else{
            if(xi + xmyi < 0){
                float x2 = x0 + (1 - G2);
                float y2 = y0 - G2;
                float a2 = TWO_THIRDS - x2 * x2 - y2 * y2;
                if(a2 > 0)
                    value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i - PRIME_X, j, x2, y2);
            }else{
                float x2 = x0 + (G2 - 1);
                float y2 = y0 + G2;
                float a2 = TWO_THIRDS - x2 * x2 - y2 * y2;
                if(a2 > 0)
                    value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i + PRIME_X, j, x2, y2);
            }

            if(yi < xmyi){
                float x2 = x0 - G2;
                float y2 = y0 - (G2 - 1);
                float a2 = TWO_THIRDS - x2 * x2 - y2 * y2;
                if(a2 > 0)
                    value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i, j - PRIME_Y, x2, y2);
            }else{
                float x2 = x0 + G2;
                float y2 = y0 + (G2 - 1);
                float a2 = TWO_THIRDS - x2 * x2 - y2 * y2;
                if(a2 > 0)
                    value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i, j + PRIME_Y, x2, y2);
            }
        }

        return value * 18.24196194486065F;
    }

    private float singleOpenSimplex2S(int seed, float x, float y, float z) {
        // 3D OpenSimplex2S case uses two offset rotated cube grids.

        // Rotation moved to TransformNoiseCoordinate method

        int i = Maths.floor(x);
        int j = Maths.floor(y);
        int k = Maths.floor(z);
        float xi = (x - i);
        float yi = (y - j);
        float zi = (z - k);

        i *= PRIME_X;
        j *= PRIME_Y;
        k *= PRIME_Z;
        int seed2 = seed + 1293373;

        int xNMask = (int) (-0.5F - xi);
        int yNMask = (int) (-0.5F - yi);
        int zNMask = (int) (-0.5F - zi);

        float x0 = xi + xNMask;
        float y0 = yi + yNMask;
        float z0 = zi + zNMask;
        float a0 = 0.75F - x0 * x0 - y0 * y0 - z0 * z0;
        float value = (a0 * a0) * (a0 * a0) * gradCoord(seed, i + (xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (zNMask & PRIME_Z), x0, y0, z0);

        float x1 = xi - 0.5F;
        float y1 = yi - 0.5F;
        float z1 = zi - 0.5F;
        float a1 = 0.75F - x1 * x1 - y1 * y1 - z1 * z1;
        value += (a1 * a1) * (a1 * a1) * gradCoord(seed2, i + PRIME_X, j + PRIME_Y, k + PRIME_Z, x1, y1, z1);

        float xAFlipMask0 = ((xNMask | 1) << 1) * x1;
        float yAFlipMask0 = ((yNMask | 1) << 1) * y1;
        float zAFlipMask0 = ((zNMask | 1) << 1) * z1;
        float xAFlipMask1 = (-2 - (xNMask << 2)) * x1 - 1F;
        float yAFlipMask1 = (-2 - (yNMask << 2)) * y1 - 1F;
        float zAFlipMask1 = (-2 - (zNMask << 2)) * z1 - 1F;

        boolean skip5 = false;
        float a2 = xAFlipMask0 + a0;
        if(a2 > 0){
            float x2 = x0 - (xNMask | 1);
            float y2 = y0;
            float z2 = z0;
            value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i + (~xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (zNMask & PRIME_Z), x2, y2, z2);
        }else{
            float a3 = yAFlipMask0 + zAFlipMask0 + a0;
            if(a3 > 0){
                float x3 = x0;
                float y3 = y0 - (yNMask | 1);
                float z3 = z0 - (zNMask | 1);
                value += (a3 * a3) * (a3 * a3) * gradCoord(seed, i + (xNMask & PRIME_X), j + (~yNMask & PRIME_Y), k + (~zNMask & PRIME_Z), x3, y3, z3);
            }

            float a4 = xAFlipMask1 + a1;
            if(a4 > 0){
                float x4 = (xNMask | 1) + x1;
                float y4 = y1;
                float z4 = z1;
                value += (a4 * a4) * (a4 * a4) * gradCoord(seed2, i + (xNMask & (PRIME_X * 2)), j + PRIME_Y, k + PRIME_Z, x4, y4, z4);
                skip5 = true;
            }
        }

        boolean skip9 = false;
        float a6 = yAFlipMask0 + a0;
        if(a6 > 0){
            float x6 = x0;
            float y6 = y0 - (yNMask | 1);
            float z6 = z0;
            value += (a6 * a6) * (a6 * a6) * gradCoord(seed, i + (xNMask & PRIME_X), j + (~yNMask & PRIME_Y), k + (zNMask & PRIME_Z), x6, y6, z6);
        }else{
            float a7 = xAFlipMask0 + zAFlipMask0 + a0;
            if(a7 > 0){
                float x7 = x0 - (xNMask | 1);
                float y7 = y0;
                float z7 = z0 - (zNMask | 1);
                value += (a7 * a7) * (a7 * a7) * gradCoord(seed, i + (~xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (~zNMask & PRIME_Z), x7, y7, z7);
            }

            float a8 = yAFlipMask1 + a1;
            if(a8 > 0){
                float x8 = x1;
                float y8 = (yNMask | 1) + y1;
                float z8 = z1;
                final int yPrimed = j + (yNMask & (PRIME_Y << 1));
                final float grad = gradCoord(seed2, i + PRIME_X, yPrimed, k + PRIME_Z, x8, y8, z8);
                value += (a8 * a8) * (a8 * a8) * grad;
                skip9 = true;
            }
        }

        boolean skipD = false;
        float aA = zAFlipMask0 + a0;
        if(aA > 0){
            float xA = x0;
            float yA = y0;
            float zA = z0 - (zNMask | 1);
            value += (aA * aA) * (aA * aA) * gradCoord(seed, i + (xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (~zNMask & PRIME_Z), xA, yA, zA);
        }else{
            float aB = xAFlipMask0 + yAFlipMask0 + a0;
            if(aB > 0){
                float xB = x0 - (xNMask | 1);
                float yB = y0 - (yNMask | 1);
                float zB = z0;
                value += (aB * aB) * (aB * aB) * gradCoord(seed, i + (~xNMask & PRIME_X), j + (~yNMask & PRIME_Y), k + (zNMask & PRIME_Z), xB, yB, zB);
            }

            float aC = zAFlipMask1 + a1;
            if(aC > 0){
                float xC = x1;
                float yC = y1;
                float zC = (zNMask | 1) + z1;
                final int zPrimed = k + (zNMask & (PRIME_Z << 1));
                final float grad = gradCoord(seed2, i + PRIME_X, j + PRIME_Y, zPrimed, xC, yC, zC);
                value += (aC * aC) * (aC * aC) * grad;
                skipD = true;
            }
        }

        if(!skip5){
            float a5 = yAFlipMask1 + zAFlipMask1 + a1;
            if(a5 > 0){
                float x5 = x1;
                float y5 = (yNMask | 1) + y1;
                float z5 = (zNMask | 1) + z1;
                final int yPrimed = j + (yNMask & (PRIME_Y << 1));
                final int zPrimed = k + (zNMask & (PRIME_Z << 1));
                final float grad = gradCoord(seed2, i + PRIME_X, yPrimed, zPrimed, x5, y5, z5);
                value += (a5 * a5) * (a5 * a5) * grad;
            }
        }

        if(!skip9){
            float a9 = xAFlipMask1 + zAFlipMask1 + a1;
            if(a9 > 0){
                float x9 = (xNMask | 1) + x1;
                float y9 = y1;
                float z9 = (zNMask | 1) + z1;
                final int zPrimed = k + (zNMask & (PRIME_Z << 1));
                final float grad = gradCoord(seed2, i + (xNMask & (PRIME_X * 2)), j + PRIME_Y, zPrimed, x9, y9, z9);
                value += (a9 * a9) * (a9 * a9) * grad;
            }
        }

        if(!skipD){
            float aD = xAFlipMask1 + yAFlipMask1 + a1;
            if(aD > 0){
                float xD = (xNMask | 1) + x1;
                float yD = (yNMask | 1) + y1;
                float zD = z1;
                final int yPrimed = j + (yNMask & (PRIME_Y << 1));
                final float grad = gradCoord(seed2, i + (xNMask & (PRIME_X << 1)), yPrimed, k + PRIME_Z, xD, yD, zD);
                value += (aD * aD) * (aD * aD) * grad;
            }
        }

        return value * 9.046026385208288F;
    }


    // Cellular Noise

    private float singleCellular(int seed, float x, float y) {
        final int xr = Maths.round(x);
        final int yr = Maths.round(y);

        float distance0 = Float.MAX_VALUE;
        float distance1 = Float.MAX_VALUE;
        int closestHash = 0;

        float cellularJitter = 0.43701595F * cellularJitterModifier;

        int xPrimed = (xr - 1) * PRIME_X;
        int yPrimedBase = (yr - 1) * PRIME_Y;

        switch(cellularDistFunc){
            case MANHATTAN: {
                for(int xi = xr - 1; xi <= xr + 1; xi++){
                    int yPrimed = yPrimedBase;

                    for(int yi = yr - 1; yi <= yr + 1; yi++){
                        int hash = hash(seed, xPrimed, yPrimed);
                        int idx = hash & (255 << 1);

                        float vecX = (xi - x) + RAND_VECS_2D[idx] * cellularJitter;
                        float vecY = (yi - y) + RAND_VECS_2D[idx | 1] * cellularJitter;

                        float newDistance = Math.abs(vecX) + Math.abs(vecY);

                        distance1 = Math.max(Math.min(distance1, newDistance), distance0);
                        if(newDistance < distance0){
                            distance0 = newDistance;
                            closestHash = hash;
                        }
                        yPrimed += PRIME_Y;
                    }
                    xPrimed += PRIME_X;
                }
                break;
            }
            case HYBRID: {
                for(int xi = xr - 1; xi <= xr + 1; xi++){
                    int yPrimed = yPrimedBase;

                    for(int yi = yr - 1; yi <= yr + 1; yi++){
                        int hash = hash(seed, xPrimed, yPrimed);
                        int idx = hash & (255 << 1);

                        float vecX = (xi - x) + RAND_VECS_2D[idx] * cellularJitter;
                        float vecY = (yi - y) + RAND_VECS_2D[idx | 1] * cellularJitter;

                        float newDistance = (Math.abs(vecX) + Math.abs(vecY)) + (vecX * vecX + vecY * vecY);

                        distance1 = Math.max(Math.min(distance1, newDistance), distance0);
                        if(newDistance < distance0){
                            distance0 = newDistance;
                            closestHash = hash;
                        }
                        yPrimed += PRIME_Y;
                    }
                    xPrimed += PRIME_X;
                }
                break;
            }
            default: {
                for(int xi = xr - 1; xi <= xr + 1; xi++){
                    int yPrimed = yPrimedBase;

                    for(int yi = yr - 1; yi <= yr + 1; yi++){
                        final int hash = hash(seed, xPrimed, yPrimed);
                        final int idx = hash & (255 << 1);

                        final float vecX = (xi - x) + RAND_VECS_2D[idx] * cellularJitter;
                        final float vecY = (yi - y) + RAND_VECS_2D[idx | 1] * cellularJitter;

                        final float newDistance = vecX * vecX + vecY * vecY;

                        distance1 = Math.max(Math.min(distance1, newDistance), distance0);
                        if(newDistance < distance0){
                            distance0 = newDistance;
                            closestHash = hash;
                        }
                        yPrimed += PRIME_Y;
                    }
                    xPrimed += PRIME_X;
                }
            }
        }

        if(cellularDistFunc == CellularDistFunc.EUCLIDEAN){
            distance0 = Mathc.sqrt(distance0);
            if(cellularReturnType != CellularReturnType.CELL_VALUE)
                distance1 = Mathc.sqrt(distance1);
        }

        switch(cellularReturnType){
            case CELL_VALUE: return (closestHash * (1 / 2147483648F));
            case DIST: return (distance0 - 1);
            case DIST_2: return (distance1 - 1);
            case DIST_2_ADD: return ((distance1 + distance0) * 0.5F - 1);
            case DIST_2_SUB: return (distance1 - distance0 - 1);
            case DIST_2_MUL: return (distance1 * distance0 * 0.5F - 1);
            case DIST_2_DIV: return (distance0 / distance1 - 1);
        }
        return 0F; // old switch syntax issue
    }

    private float singleCellular(int seed, float x, float y, float z) {
        final int xr = Maths.round(x);
        final int yr = Maths.round(y);
        final int zr = Maths.round(z);

        float distance0 = Float.MAX_VALUE;
        float distance1 = Float.MAX_VALUE;
        int closestHash = 0;

        float cellularJitter = 0.39614353F * cellularJitterModifier;

        int xPrimed = (xr - 1) * PRIME_X;
        int yPrimedBase = (yr - 1) * PRIME_Y;
        int zPrimedBase = (zr - 1) * PRIME_Z;

        switch(cellularDistFunc){
            case EUCLIDEAN:
            case EUCLIDEAN_SQ: {
                for(int xi = xr - 1; xi <= xr + 1; xi++){
                    int yPrimed = yPrimedBase;

                    for(int yi = yr - 1; yi <= yr + 1; yi++){
                        int zPrimed = zPrimedBase;

                        for(int zi = zr - 1; zi <= zr + 1; zi++){
                            int hash = hash(seed, xPrimed, yPrimed, zPrimed);
                            int idx = hash & (255 << 2);

                            float vecX = (xi - x) + RAND_VECS_3D[idx] * cellularJitter;
                            float vecY = (yi - y) + RAND_VECS_3D[idx | 1] * cellularJitter;
                            float vecZ = (zi - z) + RAND_VECS_3D[idx | 2] * cellularJitter;

                            float newDistance = vecX * vecX + vecY * vecY + vecZ * vecZ;

                            distance1 = Math.max(Math.min(distance1, newDistance), distance0);
                            if(newDistance < distance0){
                                distance0 = newDistance;
                                closestHash = hash;
                            }
                            zPrimed += PRIME_Z;
                        }
                        yPrimed += PRIME_Y;
                    }
                    xPrimed += PRIME_X;
                }
                break;
            }
            case MANHATTAN: {
                for(int xi = xr - 1; xi <= xr + 1; xi++){
                    int yPrimed = yPrimedBase;

                    for(int yi = yr - 1; yi <= yr + 1; yi++){
                        int zPrimed = zPrimedBase;

                        for(int zi = zr - 1; zi <= zr + 1; zi++){
                            int hash = hash(seed, xPrimed, yPrimed, zPrimed);
                            int idx = hash & (255 << 2);

                            float vecX = (xi - x) + RAND_VECS_3D[idx] * cellularJitter;
                            float vecY = (yi - y) + RAND_VECS_3D[idx | 1] * cellularJitter;
                            float vecZ = (zi - z) + RAND_VECS_3D[idx | 2] * cellularJitter;

                            float newDistance = Math.abs(vecX) + Math.abs(vecY) + Math.abs(vecZ);

                            distance1 = Math.max(Math.min(distance1, newDistance), distance0);
                            if(newDistance < distance0){
                                distance0 = newDistance;
                                closestHash = hash;
                            }
                            zPrimed += PRIME_Z;
                        }
                        yPrimed += PRIME_Y;
                    }
                    xPrimed += PRIME_X;
                }
                break;
            }
            case HYBRID: {
                for(int xi = xr - 1; xi <= xr + 1; xi++){
                    int yPrimed = yPrimedBase;

                    for(int yi = yr - 1; yi <= yr + 1; yi++){
                        int zPrimed = zPrimedBase;

                        for(int zi = zr - 1; zi <= zr + 1; zi++){
                            int hash = hash(seed, xPrimed, yPrimed, zPrimed);
                            int idx = hash & (255 << 2);

                            float vecX = (xi - x) + RAND_VECS_3D[idx] * cellularJitter;
                            float vecY = (yi - y) + RAND_VECS_3D[idx | 1] * cellularJitter;
                            float vecZ = (zi - z) + RAND_VECS_3D[idx | 2] * cellularJitter;

                            float newDistance = (Math.abs(vecX) + Math.abs(vecY) + Math.abs(vecZ)) + (vecX * vecX + vecY * vecY + vecZ * vecZ);

                            distance1 = Math.max(Math.min(distance1, newDistance), distance0);
                            if(newDistance < distance0){
                                distance0 = newDistance;
                                closestHash = hash;
                            }
                            zPrimed += PRIME_Z;
                        }
                        yPrimed += PRIME_Y;
                    }
                    xPrimed += PRIME_X;
                }
            }
        }

        if(cellularDistFunc == CellularDistFunc.EUCLIDEAN){
            distance0 = Mathc.sqrt(distance0);
            if(cellularReturnType != CellularReturnType.CELL_VALUE)
                distance1 = Mathc.sqrt(distance1);
        }

        switch(cellularReturnType){
            case CELL_VALUE: return (closestHash * (1 / 2147483648F));
            case DIST: return (distance0 - 1);
            case DIST_2: return (distance1 - 1);
            case DIST_2_ADD: return ((distance1 + distance0) * 0.5F - 1);
            case DIST_2_SUB: return (distance1 - distance0 - 1);
            case DIST_2_MUL: return (distance1 * distance0 * 0.5F - 1);
            case DIST_2_DIV: return (distance0 / distance1 - 1);
        }
        return 0F; // old switch syntax issue
    }


    // Perlin Noise

    private float singlePerlin(int seed, float x, float y) {
        int x0 = Maths.floor(x);
        int y0 = Maths.floor(y);

        float xd0 = (x - x0);
        float yd0 = (y - y0);
        float xd1 = xd0 - 1;
        float yd1 = yd0 - 1;

        float xs = Maths.quintic(xd0);
        float ys = Maths.quintic(yd0);

        x0 *= PRIME_X;
        y0 *= PRIME_Y;
        int x1 = x0 + PRIME_X;
        int y1 = y0 + PRIME_Y;

        float xf0 = Maths.lerp(gradCoord(seed, x0, y0, xd0, yd0), gradCoord(seed, x1, y0, xd1, yd0), xs);
        float xf1 = Maths.lerp(gradCoord(seed, x0, y1, xd0, yd1), gradCoord(seed, x1, y1, xd1, yd1), xs);

        return Maths.lerp(xf0, xf1, ys) * 1.4247691104677813F;
    }

    private float singlePerlin(int seed, float x, float y, float z) {
        int x0 = Maths.floor(x);
        int y0 = Maths.floor(y);
        int z0 = Maths.floor(z);

        float xd0 = (x - x0);
        float yd0 = (y - y0);
        float zd0 = (z - z0);
        float xd1 = xd0 - 1;
        float yd1 = yd0 - 1;
        float zd1 = zd0 - 1;

        float xs = Maths.quintic(xd0);
        float ys = Maths.quintic(yd0);
        float zs = Maths.quintic(zd0);

        x0 *= PRIME_X;
        y0 *= PRIME_Y;
        z0 *= PRIME_Z;
        int x1 = x0 + PRIME_X;
        int y1 = y0 + PRIME_Y;
        int z1 = z0 + PRIME_Z;

        float xf00 = Maths.lerp(gradCoord(seed, x0, y0, z0, xd0, yd0, zd0), gradCoord(seed, x1, y0, z0, xd1, yd0, zd0), xs);
        float xf10 = Maths.lerp(gradCoord(seed, x0, y1, z0, xd0, yd1, zd0), gradCoord(seed, x1, y1, z0, xd1, yd1, zd0), xs);
        float xf01 = Maths.lerp(gradCoord(seed, x0, y0, z1, xd0, yd0, zd1), gradCoord(seed, x1, y0, z1, xd1, yd0, zd1), xs);
        float xf11 = Maths.lerp(gradCoord(seed, x0, y1, z1, xd0, yd1, zd1), gradCoord(seed, x1, y1, z1, xd1, yd1, zd1), xs);

        float yf0 = Maths.lerp(xf00, xf10, ys);
        float yf1 = Maths.lerp(xf01, xf11, ys);

        return Maths.lerp(yf0, yf1, zs) * 0.964921414852142333984375F;
    }


    // Value Cubic Noise

    private float singleValueCubic(int seed, float x, float y) {
        int x1 = Maths.floor(x);
        int y1 = Maths.floor(y);

        float xs = (x - x1);
        float ys = (y - y1);

        x1 *= PRIME_X;
        y1 *= PRIME_Y;
        int x0 = x1 - PRIME_X;
        int y0 = y1 - PRIME_Y;
        int x2 = x1 + PRIME_X;
        int y2 = y1 + PRIME_Y;
        int x3 = x1 + (PRIME_X << 1);
        int y3 = y1 + (PRIME_Y << 1);

        return Maths.cerp(
            Maths.cerp(valCoord(seed, x0, y0), valCoord(seed, x1, y0), valCoord(seed, x2, y0), valCoord(seed, x3, y0), xs),
            Maths.cerp(valCoord(seed, x0, y1), valCoord(seed, x1, y1), valCoord(seed, x2, y1), valCoord(seed, x3, y1), xs),
            Maths.cerp(valCoord(seed, x0, y2), valCoord(seed, x1, y2), valCoord(seed, x2, y2), valCoord(seed, x3, y2), xs),
            Maths.cerp(valCoord(seed, x0, y3), valCoord(seed, x1, y3), valCoord(seed, x2, y3), valCoord(seed, x3, y3), xs),
            ys
        ) * (1 / (1.5F * 1.5F));
    }

    private float singleValueCubic(int seed, float x, float y, float z) {
        int x1 = Maths.floor(x);
        int y1 = Maths.floor(y);
        int z1 = Maths.floor(z);

        float xs = (x - x1);
        float ys = (y - y1);
        float zs = (z - z1);

        x1 *= PRIME_X;
        y1 *= PRIME_Y;
        z1 *= PRIME_Z;

        int x0 = x1 - PRIME_X;
        int y0 = y1 - PRIME_Y;
        int z0 = z1 - PRIME_Z;
        int x2 = x1 + PRIME_X;
        int y2 = y1 + PRIME_Y;
        int z2 = z1 + PRIME_Z;
        int x3 = x1 + (PRIME_X << 1);
        int y3 = y1 + (PRIME_Y << 1);
        int z3 = z1 + (PRIME_Z << 1);

        return Maths.cerp(
            Maths.cerp(
                Maths.cerp(valCoord(seed, x0, y0, z0), valCoord(seed, x1, y0, z0), valCoord(seed, x2, y0, z0), valCoord(seed, x3, y0, z0), xs),
                Maths.cerp(valCoord(seed, x0, y1, z0), valCoord(seed, x1, y1, z0), valCoord(seed, x2, y1, z0), valCoord(seed, x3, y1, z0), xs),
                Maths.cerp(valCoord(seed, x0, y2, z0), valCoord(seed, x1, y2, z0), valCoord(seed, x2, y2, z0), valCoord(seed, x3, y2, z0), xs),
                Maths.cerp(valCoord(seed, x0, y3, z0), valCoord(seed, x1, y3, z0), valCoord(seed, x2, y3, z0), valCoord(seed, x3, y3, z0), xs),
                ys
            ),
            Maths.cerp(
                Maths.cerp(valCoord(seed, x0, y0, z1), valCoord(seed, x1, y0, z1), valCoord(seed, x2, y0, z1), valCoord(seed, x3, y0, z1), xs),
                Maths.cerp(valCoord(seed, x0, y1, z1), valCoord(seed, x1, y1, z1), valCoord(seed, x2, y1, z1), valCoord(seed, x3, y1, z1), xs),
                Maths.cerp(valCoord(seed, x0, y2, z1), valCoord(seed, x1, y2, z1), valCoord(seed, x2, y2, z1), valCoord(seed, x3, y2, z1), xs),
                Maths.cerp(valCoord(seed, x0, y3, z1), valCoord(seed, x1, y3, z1), valCoord(seed, x2, y3, z1), valCoord(seed, x3, y3, z1), xs),
                ys
            ),
            Maths.cerp(
                Maths.cerp(valCoord(seed, x0, y0, z2), valCoord(seed, x1, y0, z2), valCoord(seed, x2, y0, z2), valCoord(seed, x3, y0, z2), xs),
                Maths.cerp(valCoord(seed, x0, y1, z2), valCoord(seed, x1, y1, z2), valCoord(seed, x2, y1, z2), valCoord(seed, x3, y1, z2), xs),
                Maths.cerp(valCoord(seed, x0, y2, z2), valCoord(seed, x1, y2, z2), valCoord(seed, x2, y2, z2), valCoord(seed, x3, y2, z2), xs),
                Maths.cerp(valCoord(seed, x0, y3, z2), valCoord(seed, x1, y3, z2), valCoord(seed, x2, y3, z2), valCoord(seed, x3, y3, z2), xs),
                ys
            ),
            Maths.cerp(
                Maths.cerp(valCoord(seed, x0, y0, z3), valCoord(seed, x1, y0, z3), valCoord(seed, x2, y0, z3), valCoord(seed, x3, y0, z3), xs),
                Maths.cerp(valCoord(seed, x0, y1, z3), valCoord(seed, x1, y1, z3), valCoord(seed, x2, y1, z3), valCoord(seed, x3, y1, z3), xs),
                Maths.cerp(valCoord(seed, x0, y2, z3), valCoord(seed, x1, y2, z3), valCoord(seed, x2, y2, z3), valCoord(seed, x3, y2, z3), xs),
                Maths.cerp(valCoord(seed, x0, y3, z3), valCoord(seed, x1, y3, z3), valCoord(seed, x2, y3, z3), valCoord(seed, x3, y3, z3), xs),
                ys
            ),
            zs
        ) * (1 / (1.5F * 1.5F * 1.5F));
    }


    // Value Noise

    private float singleValue(int seed, float x, float y) {
        int x0 = Maths.floor(x);
        int y0 = Maths.floor(y);

        float xs = Maths.hermite(x - x0);
        float ys = Maths.hermite(y - y0);

        x0 *= PRIME_X;
        y0 *= PRIME_Y;
        final int x1 = x0 + PRIME_X;
        final int y1 = y0 + PRIME_Y;

        final float xf0 = Maths.lerp(valCoord(seed, x0, y0), valCoord(seed, x1, y0), xs);
        final float xf1 = Maths.lerp(valCoord(seed, x0, y1), valCoord(seed, x1, y1), xs);

        return Maths.lerp(xf0, xf1, ys);
    }

    private float singleValue(int seed, float x, float y, float z) {
        int x0 = Maths.floor(x);
        int y0 = Maths.floor(y);
        int z0 = Maths.floor(z);

        float xs = Maths.hermite(x - x0);
        float ys = Maths.hermite(y - y0);
        float zs = Maths.hermite(z - z0);

        x0 *= PRIME_X;
        y0 *= PRIME_Y;
        z0 *= PRIME_Z;
        final int x1 = x0 + PRIME_X;
        final int y1 = y0 + PRIME_Y;
        final int z1 = z0 + PRIME_Z;

        final float xf00 = Maths.lerp(valCoord(seed, x0, y0, z0), valCoord(seed, x1, y0, z0), xs);
        final float xf10 = Maths.lerp(valCoord(seed, x0, y1, z0), valCoord(seed, x1, y1, z0), xs);
        final float xf01 = Maths.lerp(valCoord(seed, x0, y0, z1), valCoord(seed, x1, y0, z1), xs);
        final float xf11 = Maths.lerp(valCoord(seed, x0, y1, z1), valCoord(seed, x1, y1, z1), xs);

        final float yf0 = Maths.lerp(xf00, xf10, ys);
        final float yf1 = Maths.lerp(xf01, xf11, ys);

        return Maths.lerp(yf0, yf1, zs);
    }


    // Domain Warp

    private void doSingleDomainWarp(int seed, float amp, float freq, float x, float y, Vec2f coord) {
        switch(domainWarpType){
            case OPEN_SIMPLEX_2: {
                singleDomainWarpSimplexGradient(seed, amp * 38.283687591552734375F, freq, x, y, coord, false);
                break;
            }
            case OPEN_SIMPLEX_2_REDUCED: {
                singleDomainWarpSimplexGradient(seed, amp * 16F, freq, x, y, coord, true);
                break;
            }
            case BASIC_GRID: {
                singleDomainWarpBasicGrid(seed, amp, freq, x, y, coord);
                break;
            }
        }
    }

    private void doSingleDomainWarp(int seed, float amp, float freq, float x, float y, float z, Vec3f coord) {
        switch(domainWarpType){
            case OPEN_SIMPLEX_2: {
                singleDomainWarpOpenSimplex2Gradient(seed, amp * 32.69428253173828125F, freq, x, y, z, coord, false);
                break;
            }
            case OPEN_SIMPLEX_2_REDUCED: {
                singleDomainWarpOpenSimplex2Gradient(seed, amp * 7.71604938271605F, freq, x, y, z, coord, true);
                break;
            }
            case BASIC_GRID: {
                singleDomainWarpBasicGrid(seed, amp, freq, x, y, z, coord);
                break;
            }
        }
    }


    // Domain Warp Single Wrapper

    private void domainWarpSingle(Vec2f coord) {
        final float amp = domainWarpAmp * fractalBounding;

        float xs = coord.x;
        float ys = coord.y;
        switch(domainWarpType){
            case OPEN_SIMPLEX_2:
            case OPEN_SIMPLEX_2_REDUCED: {
                final float F2 = 0.5F * (Maths.SQRT3 - 1);
                final float t = (xs + ys) * F2;
                xs += t;
                ys += t;
            }
        }

        doSingleDomainWarp(seed, amp, frequency, xs, ys, coord);
    }

    private void domainWarpSingle(Vec3f coord) {
        final float amp = domainWarpAmp * fractalBounding;

        float xs = coord.x;
        float ys = coord.y;
        float zs = coord.z;
        switch(warpTransformType3D){
            case IMPROVE_XY_PLANES: {
                final float xy = xs + ys;
                final float s2 = xy * -0.211324865405187F;
                zs *=  0.577350269189626F;
                xs += s2 - zs;
                ys = ys + s2 - zs;
                zs += xy * 0.577350269189626F;
                break;
            }
            case IMPROVE_XZ_PLANES: {
                final float xz = xs + zs;
                final float s2 = xz * - 0.211324865405187F;
                ys *= 0.577350269189626F;
                xs += s2 - ys;
                zs += s2 - ys;
                ys += xz * 0.577350269189626F;
                break;
            }
            case DEFAULT_OPEN_SIMPLEX_2: {
                final float R3 = TWO_THIRDS;
                final float r = (xs + ys + zs) * R3; // Rotation, not skew
                xs = r - xs;
                ys = r - ys;
                zs = r - zs;
                break;
            }
        }

        doSingleDomainWarp(seed, amp, frequency, xs, ys, zs, coord);
    }


    // Domain Warp Fractal Progressive

    private void domainWarpFractalProgressive(Vec2f coord) {
        int seed = this.seed;
        float amp = domainWarpAmp * fractalBounding;
        float freq = frequency;

        for(int i = 0; i < octaves; i++){
            float xs = coord.x;
            float ys = coord.y;
            switch(domainWarpType){
                case OPEN_SIMPLEX_2:
                case OPEN_SIMPLEX_2_REDUCED: {
                    final float F2 = 0.5F * (Maths.SQRT3 - 1);
                    final float t = (xs + ys) * F2;
                    xs += t;
                    ys += t;
                }
            }

            doSingleDomainWarp(seed, amp, freq, xs, ys, coord);

            seed++;
            amp *= gain;
            freq *= lacunarity;
        }
    }

    private void domainWarpFractalProgressive(Vec3f coord) {
        int seed = this.seed;
        float amp = domainWarpAmp * fractalBounding;
        float freq = frequency;

        for(int i = 0; i < octaves; i++){
            float xs = coord.x;
            float ys = coord.y;
            float zs = coord.z;
            switch(warpTransformType3D){
                case IMPROVE_XY_PLANES: {
                    final float xy = xs + ys;
                    final float s2 = xy * -0.211324865405187F;
                    zs *=  0.577350269189626F;
                    xs += s2 - zs;
                    ys = ys + s2 - zs;
                    zs += xy * 0.577350269189626F;
                    break;
                }
                case IMPROVE_XZ_PLANES: {
                    final float xz = xs + zs;
                    final float s2 = xz * -0.211324865405187F;
                    ys *=  0.577350269189626F;
                    xs += s2 - ys;
                    zs += s2 - ys;
                    ys += xz * 0.577350269189626F;
                    break;
                }
                case DEFAULT_OPEN_SIMPLEX_2: {
                    final float R3 = TWO_THIRDS;
                    final float r = (xs + ys + zs) * R3; // Rotation, not skew
                    xs = r - xs;
                    ys = r - ys;
                    zs = r - zs;
                    break;
                }
            }

            doSingleDomainWarp(seed, amp, freq, xs, ys, zs, coord);

            seed++;
            amp *= gain;
            freq *= lacunarity;
        }
    }


    // Domain Warp Fractal Independent

    private void domainWarpFractalIndependent(Vec2f coord) {
        float xs = coord.x;
        float ys = coord.y;
        switch(domainWarpType){
            case OPEN_SIMPLEX_2:
            case OPEN_SIMPLEX_2_REDUCED: {
                final float F2 = 0.5F * (Maths.SQRT3 - 1);
                final float t = (xs + ys) * F2;
                xs += t;
                ys += t;
            }
        }

        int seed = this.seed;
        float amp = domainWarpAmp * fractalBounding;
        float freq = frequency;

        for(int i = 0; i < octaves; i++){
            doSingleDomainWarp(seed, amp, freq, xs, ys, coord);

            seed++;
            amp *= gain;
            freq *= lacunarity;
        }
    }

    private void domainWarpFractalIndependent(Vec3f coord) {
        float xs = coord.x;
        float ys = coord.y;
        float zs = coord.z;
        switch(warpTransformType3D){
            case IMPROVE_XY_PLANES: {
                final float xy = xs + ys;
                final float s2 = xy * -0.211324865405187F;
                zs *= 0.577350269189626F;
                xs += s2 - zs;
                ys = ys + s2 - zs;
                zs += xy * 0.577350269189626F;
                break;
            }
            case IMPROVE_XZ_PLANES: {
                final float xz = xs + zs;
                final float s2 = xz * -0.211324865405187F;
                ys *= 0.577350269189626F;
                xs += s2 - ys;
                zs += s2 - ys;
                ys += xz * 0.577350269189626F;
                break;
            }
            case DEFAULT_OPEN_SIMPLEX_2: {
                final float R3 = TWO_THIRDS;
                final float r = (xs + ys + zs) * R3; // Rotation, not skew
                xs = r - xs;
                ys = r - ys;
                zs = r - zs;
                break;
            }
        }

        int seed = this.seed;
        float amp = domainWarpAmp * fractalBounding;
        float freq = frequency;

        for(int i = 0; i < octaves; i++){
            doSingleDomainWarp(seed, amp, freq, xs, ys, zs, coord);

            seed++;
            amp *= gain;
            freq *= lacunarity;
        }
    }


    // Domain Warp Basic Grid

    private void singleDomainWarpBasicGrid(int seed, float warpAmp, float frequency, float x, float y, Vec2f coord) {
        float xf = x * frequency;
        float yf = y * frequency;

        int x0 = Maths.floor(xf);
        int y0 = Maths.floor(yf);

        float xs = Maths.hermite(xf - x0);
        float ys = Maths.hermite(yf - y0);

        x0 *= PRIME_X;
        y0 *= PRIME_Y;
        int x1 = x0 + PRIME_X;
        int y1 = y0 + PRIME_Y;

        int hash0 = hash(seed, x0, y0) & (255 << 1);
        int hash1 = hash(seed, x1, y0) & (255 << 1);

        float lx0x = Maths.lerp(RAND_VECS_2D[hash0], RAND_VECS_2D[hash1], xs);
        float ly0x = Maths.lerp(RAND_VECS_2D[hash0 | 1], RAND_VECS_2D[hash1 | 1], xs);

        hash0 = hash(seed, x0, y1) & (255 << 1);
        hash1 = hash(seed, x1, y1) & (255 << 1);

        float lx1x = Maths.lerp(RAND_VECS_2D[hash0], RAND_VECS_2D[hash1], xs);
        float ly1x = Maths.lerp(RAND_VECS_2D[hash0 | 1], RAND_VECS_2D[hash1 | 1], xs);

        coord.x += Maths.lerp(lx0x, lx1x, ys) * warpAmp;
        coord.y += Maths.lerp(ly0x, ly1x, ys) * warpAmp;
    }

    private void singleDomainWarpBasicGrid(int seed, float warpAmp, float frequency, float x, float y, float z, Vec3f coord) {
        float xf = x * frequency;
        float yf = y * frequency;
        float zf = z * frequency;

        int x0 = Maths.floor(xf);
        int y0 = Maths.floor(yf);
        int z0 = Maths.floor(zf);

        float xs = Maths.hermite(xf - x0);
        float ys = Maths.hermite(yf - y0);
        float zs = Maths.hermite(zf - z0);

        x0 *= PRIME_X;
        y0 *= PRIME_Y;
        z0 *= PRIME_Z;
        int x1 = x0 + PRIME_X;
        int y1 = y0 + PRIME_Y;
        int z1 = z0 + PRIME_Z;

        int hash0 = hash(seed, x0, y0, z0) & (255 << 2);
        int hash1 = hash(seed, x1, y0, z0) & (255 << 2);

        float lx0x = Maths.lerp(RAND_VECS_3D[hash0], RAND_VECS_3D[hash1], xs);
        float ly0x = Maths.lerp(RAND_VECS_3D[hash0 | 1], RAND_VECS_3D[hash1 | 1], xs);
        float lz0x = Maths.lerp(RAND_VECS_3D[hash0 | 2], RAND_VECS_3D[hash1 | 2], xs);

        hash0 = hash(seed, x0, y1, z0) & (255 << 2);
        hash1 = hash(seed, x1, y1, z0) & (255 << 2);

        float lx1x = Maths.lerp(RAND_VECS_3D[hash0], RAND_VECS_3D[hash1], xs);
        float ly1x = Maths.lerp(RAND_VECS_3D[hash0 | 1], RAND_VECS_3D[hash1 | 1], xs);
        float lz1x = Maths.lerp(RAND_VECS_3D[hash0 | 2], RAND_VECS_3D[hash1 | 2], xs);

        float lx0y = Maths.lerp(lx0x, lx1x, ys);
        float ly0y = Maths.lerp(ly0x, ly1x, ys);
        float lz0y = Maths.lerp(lz0x, lz1x, ys);

        hash0 = hash(seed, x0, y0, z1) & (255 << 2);
        hash1 = hash(seed, x1, y0, z1) & (255 << 2);

        lx0x = Maths.lerp(RAND_VECS_3D[hash0], RAND_VECS_3D[hash1], xs);
        ly0x = Maths.lerp(RAND_VECS_3D[hash0 | 1], RAND_VECS_3D[hash1 | 1], xs);
        lz0x = Maths.lerp(RAND_VECS_3D[hash0 | 2], RAND_VECS_3D[hash1 | 2], xs);

        hash0 = hash(seed, x0, y1, z1) & (255 << 2);
        hash1 = hash(seed, x1, y1, z1) & (255 << 2);

        lx1x = Maths.lerp(RAND_VECS_3D[hash0], RAND_VECS_3D[hash1], xs);
        ly1x = Maths.lerp(RAND_VECS_3D[hash0 | 1], RAND_VECS_3D[hash1 | 1], xs);
        lz1x = Maths.lerp(RAND_VECS_3D[hash0 | 2], RAND_VECS_3D[hash1 | 2], xs);

        coord.x += Maths.lerp(lx0y, Maths.lerp(lx0x, lx1x, ys), zs) * warpAmp;
        coord.y += Maths.lerp(ly0y, Maths.lerp(ly0x, ly1x, ys), zs) * warpAmp;
        coord.z += Maths.lerp(lz0y, Maths.lerp(lz0x, lz1x, ys), zs) * warpAmp;
    }

    // Domain Warp Simplex/OpenSimplex2

    private void singleDomainWarpSimplexGradient(int seed, float warpAmp, float frequency, float x, float y, Vec2f coord, boolean outGradOnly) {
        final float G2 = (3 - Maths.SQRT3) / 6;

        x *= frequency;
        y *= frequency;

        // Skew moved to switch statements before fractal evaluation

        int i = Maths.floor(x);
        int j = Maths.floor(y);
        float xi = (x - i);
        float yi = (y - j);

        float t = (xi + yi) * G2;
        float x0 = (xi - t);
        float y0 = (yi - t);

        i *= PRIME_X;
        j *= PRIME_Y;

        float vx, vy;
        vx = vy = 0;

        float a = 0.5F - x0 * x0 - y0 * y0;
        if(a > 0){
            float aaaa = (a * a) * (a * a);
            float xo, yo;
            if(outGradOnly){
                int hash = hash(seed, i, j) & (255 << 1);
                xo = RAND_VECS_2D[hash];
                yo = RAND_VECS_2D[hash | 1];
            }else{
                int hash = hash(seed, i, j);
                int index1 = hash & (127 << 1);
                int index2 = (hash >> 7) & (255 << 1);
                float xg = GRADIENTS_2D[index1];
                float yg = GRADIENTS_2D[index1 | 1];
                float value = x0 * xg + y0 * yg;
                float xgo = RAND_VECS_2D[index2];
                float ygo = RAND_VECS_2D[index2 | 1];
                xo = value * xgo;
                yo = value * ygo;
            }
            vx += aaaa * xo;
            vy += aaaa * yo;
        }

        float c = (2 * (1 - 2 * G2) * (1 / G2 - 2)) * t + ((-2 * (1 - 2 * G2) * (1 - 2 * G2)) + a);
        if(c > 0){
            float x2 = x0 + (2 * G2 - 1);
            float y2 = y0 + (2 * G2 - 1);
            float cccc = c * c * c * c;
            float xo, yo;
            if(outGradOnly){
                int hash = hash(seed, i + PRIME_X, j + PRIME_Y) & (255 << 1);
                xo = RAND_VECS_2D[hash];
                yo = RAND_VECS_2D[hash | 1];
            }else{
                int hash = hash(seed, i + PRIME_X, j + PRIME_Y);
                int index1 = hash & (127 << 1);
                int index2 = (hash >> 7) & (255 << 1);
                float xg = GRADIENTS_2D[index1];
                float yg = GRADIENTS_2D[index1 | 1];
                float value = x2 * xg + y2 * yg;
                float xgo = RAND_VECS_2D[index2];
                float ygo = RAND_VECS_2D[index2 | 1];
                xo = value * xgo;
                yo = value * ygo;
            }
            vx += cccc * xo;
            vy += cccc * yo;
        }

        if(y0 > x0){
            float x1 = x0 + G2;
            float y1 = y0 + (G2 - 1);
            float b = 0.5F - x1 * x1 - y1 * y1;
            if(b > 0){
                float bbbb = b * b * b * b;
                float xo, yo;
                if(outGradOnly){
                    int hash = hash(seed, i, j + PRIME_Y) & (255 << 1);
                    xo = RAND_VECS_2D[hash];
                    yo = RAND_VECS_2D[hash | 1];
                }else{
                    int hash = hash(seed, i, j + PRIME_Y);
                    int index1 = hash & (127 << 1);
                    int index2 = (hash >> 7) & (255 << 1);
                    float xg = GRADIENTS_2D[index1];
                    float yg = GRADIENTS_2D[index1 | 1];
                    float value = x1 * xg + y1 * yg;
                    float xgo = RAND_VECS_2D[index2];
                    float ygo = RAND_VECS_2D[index2 | 1];
                    xo = value * xgo;
                    yo = value * ygo;
                }
                vx += bbbb * xo;
                vy += bbbb * yo;
            }
        }else{
            float x1 = x0 + (G2 - 1);
            float y1 = y0 + G2;
            float b = 0.5F - x1 * x1 - y1 * y1;
            if(b > 0){
                float bbbb = (b * b) * (b * b);
                float xo, yo;
                if(outGradOnly){
                    int hash = hash(seed, i + PRIME_X, j) & (255 << 1);
                    xo = RAND_VECS_2D[hash];
                    yo = RAND_VECS_2D[hash | 1];
                }else{
                    int hash = hash(seed, i + PRIME_X, j);
                    int index1 = hash & (127 << 1);
                    int index2 = (hash >> 7) & (255 << 1);
                    float xg = GRADIENTS_2D[index1];
                    float yg = GRADIENTS_2D[index1 | 1];
                    float value = x1 * xg + y1 * yg;
                    float xgo = RAND_VECS_2D[index2];
                    float ygo = RAND_VECS_2D[index2 | 1];
                    xo = value * xgo;
                    yo = value * ygo;
                }
                vx += bbbb * xo;
                vy += bbbb * yo;
            }
        }

        coord.x += vx * warpAmp;
        coord.y += vy * warpAmp;
    }

    private void singleDomainWarpOpenSimplex2Gradient(int seed, float warpAmp, float frequency, float x, float y, float z, Vec3f coord, boolean outGradOnly) {
        x *= frequency;
        y *= frequency;
        z *= frequency;

        // Rotation moved to switch statements before fractal evaluation

        int i = Maths.round(x);
        int j = Maths.round(y);
        int k = Maths.round(z);
        float x0 = x - i;
        float y0 = y - j;
        float z0 = z - k;

        int xNSign = (int) (-x0 - 1F) | 1;
        int yNSign = (int) (-y0 - 1F) | 1;
        int zNSign = (int) (-z0 - 1F) | 1;

        float ax0 = xNSign * -x0;
        float ay0 = yNSign * -y0;
        float az0 = zNSign * -z0;

        i *= PRIME_X;
        j *= PRIME_Y;
        k *= PRIME_Z;

        float vx, vy, vz;
        vx = vy = vz = 0;

        float a = (0.6F - x0 * x0) - (y0 * y0 + z0 * z0);
        for(int l = 0; ; l++){
            if(a > 0){
                float aaaa = (a * a) * (a * a);
                float xo, yo, zo;
                if(outGradOnly){
                    int hash = hash(seed, i, j, k) & (255 << 2);
                    xo = RAND_VECS_3D[hash];
                    yo = RAND_VECS_3D[hash | 1];
                    zo = RAND_VECS_3D[hash | 2];
                }else{
                    int hash = hash(seed, i, j, k);
                    int index1 = hash & (63 << 2);
                    int index2 = (hash >> 6) & (255 << 2);
                    float xg = GRADIENTS_3D[index1];
                    float yg = GRADIENTS_3D[index1 | 1];
                    float zg = GRADIENTS_3D[index1 | 2];
                    float value = x0 * xg + y0 * yg + z0 * zg;
                    float xgo = RAND_VECS_3D[index2];
                    float ygo = RAND_VECS_3D[index2 | 1];
                    float zgo = RAND_VECS_3D[index2 | 2];
                    xo = value * xgo;
                    yo = value * ygo;
                    zo = value * zgo;
                }
                vx += aaaa * xo;
                vy += aaaa * yo;
                vz += aaaa * zo;
            }

            float b = a;
            int i1 = i;
            int j1 = j;
            int k1 = k;
            float x1 = x0;
            float y1 = y0;
            float z1 = z0;

            if(ax0 >= ay0 && ax0 >= az0){
                x1 += xNSign;
                b = b + ax0 + ax0;
                i1 -= xNSign * PRIME_X;
            }else if(ay0 > ax0 && ay0 >= az0){
                y1 += yNSign;
                b = b + ay0 + ay0;
                j1 -= yNSign * PRIME_Y;
            }else{
                z1 += zNSign;
                b = b + az0 + az0;
                k1 -= zNSign * PRIME_Z;
            }

            if(b > 1){
                b -= 1;
                float bbbb = (b * b) * (b * b);
                float xo, yo, zo;
                if(outGradOnly){
                    int hash = hash(seed, i1, j1, k1) & (255 << 2);
                    xo = RAND_VECS_3D[hash];
                    yo = RAND_VECS_3D[hash | 1];
                    zo = RAND_VECS_3D[hash | 2];
                }else{
                    int hash = hash(seed, i1, j1, k1);
                    int index1 = hash & (63 << 2);
                    int index2 = (hash >> 6) & (255 << 2);
                    float xg = GRADIENTS_3D[index1];
                    float yg = GRADIENTS_3D[index1 | 1];
                    float zg = GRADIENTS_3D[index1 | 2];
                    float value = x1 * xg + y1 * yg + z1 * zg;
                    float xgo = RAND_VECS_3D[index2];
                    float ygo = RAND_VECS_3D[index2 | 1];
                    float zgo = RAND_VECS_3D[index2 | 2];
                    xo = value * xgo;
                    yo = value * ygo;
                    zo = value * zgo;
                }
                vx += bbbb * xo;
                vy += bbbb * yo;
                vz += bbbb * zo;
            }

            if(l == 1)
                break;

            ax0 = 0.5F - ax0;
            ay0 = 0.5F - ay0;
            az0 = 0.5F - az0;

            x0 = xNSign * ax0;
            y0 = yNSign * ay0;
            z0 = zNSign * az0;

            a += (0.75F - ax0) - (ay0 + az0);

            i += (xNSign >> 1) & PRIME_X;
            j += (yNSign >> 1) & PRIME_Y;
            k += (zNSign >> 1) & PRIME_Z;

            xNSign = -xNSign;
            yNSign = -yNSign;
            zNSign = -zNSign;

            seed += 1293373;
        }

        coord.x += vx * warpAmp;
        coord.y += vy * warpAmp;
        coord.z += vz * warpAmp;
    }

}
